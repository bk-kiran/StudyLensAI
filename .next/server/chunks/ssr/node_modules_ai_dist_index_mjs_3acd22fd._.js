module.exports = {

"[project]/node_modules/ai/dist/index.mjs [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AbstractChat": (()=>AbstractChat),
    "DefaultChatTransport": (()=>DefaultChatTransport),
    "DownloadError": (()=>DownloadError),
    "GLOBAL_DEFAULT_PROVIDER": (()=>GLOBAL_DEFAULT_PROVIDER),
    "InvalidArgumentError": (()=>InvalidArgumentError),
    "InvalidDataContentError": (()=>InvalidDataContentError),
    "InvalidMessageRoleError": (()=>InvalidMessageRoleError),
    "InvalidStreamPartError": (()=>InvalidStreamPartError),
    "InvalidToolArgumentsError": (()=>InvalidToolArgumentsError),
    "JsonToSseTransformStream": (()=>JsonToSseTransformStream),
    "MCPClientError": (()=>MCPClientError),
    "MessageConversionError": (()=>MessageConversionError),
    "NoImageGeneratedError": (()=>NoImageGeneratedError),
    "NoObjectGeneratedError": (()=>NoObjectGeneratedError),
    "NoOutputSpecifiedError": (()=>NoOutputSpecifiedError),
    "NoSuchProviderError": (()=>NoSuchProviderError),
    "NoSuchToolError": (()=>NoSuchToolError),
    "Output": (()=>output_exports),
    "RetryError": (()=>RetryError),
    "SerialJobExecutor": (()=>SerialJobExecutor),
    "TextStreamChatTransport": (()=>TextStreamChatTransport),
    "ToolCallRepairError": (()=>ToolCallRepairError),
    "ToolExecutionError": (()=>ToolExecutionError),
    "assistantModelMessageSchema": (()=>assistantModelMessageSchema),
    "callCompletionApi": (()=>callCompletionApi),
    "convertFileListToFileUIParts": (()=>convertFileListToFileUIParts),
    "convertToCoreMessages": (()=>convertToCoreMessages),
    "convertToModelMessages": (()=>convertToModelMessages),
    "coreAssistantMessageSchema": (()=>coreAssistantMessageSchema),
    "coreMessageSchema": (()=>coreMessageSchema),
    "coreSystemMessageSchema": (()=>coreSystemMessageSchema),
    "coreToolMessageSchema": (()=>coreToolMessageSchema),
    "coreUserMessageSchema": (()=>coreUserMessageSchema),
    "cosineSimilarity": (()=>cosineSimilarity),
    "createProviderRegistry": (()=>createProviderRegistry),
    "createTextStreamResponse": (()=>createTextStreamResponse),
    "createUIMessageStream": (()=>createUIMessageStream),
    "createUIMessageStreamResponse": (()=>createUIMessageStreamResponse),
    "customProvider": (()=>customProvider),
    "defaultSettingsMiddleware": (()=>defaultSettingsMiddleware),
    "embed": (()=>embed),
    "embedMany": (()=>embedMany),
    "experimental_createMCPClient": (()=>createMCPClient),
    "experimental_createProviderRegistry": (()=>experimental_createProviderRegistry),
    "experimental_customProvider": (()=>experimental_customProvider),
    "experimental_generateImage": (()=>generateImage),
    "experimental_generateSpeech": (()=>generateSpeech),
    "experimental_transcribe": (()=>transcribe),
    "extractReasoningMiddleware": (()=>extractReasoningMiddleware),
    "generateObject": (()=>generateObject),
    "generateText": (()=>generateText),
    "getTextFromDataUrl": (()=>getTextFromDataUrl),
    "getToolInvocations": (()=>getToolInvocations),
    "hasToolCall": (()=>hasToolCall),
    "isDeepEqualData": (()=>isDeepEqualData),
    "modelMessageSchema": (()=>modelMessageSchema),
    "parsePartialJson": (()=>parsePartialJson),
    "pipeTextStreamToResponse": (()=>pipeTextStreamToResponse),
    "pipeUIMessageStreamToResponse": (()=>pipeUIMessageStreamToResponse),
    "simulateReadableStream": (()=>simulateReadableStream),
    "simulateStreamingMiddleware": (()=>simulateStreamingMiddleware),
    "smoothStream": (()=>smoothStream),
    "stepCountIs": (()=>stepCountIs),
    "streamObject": (()=>streamObject),
    "streamText": (()=>streamText),
    "systemModelMessageSchema": (()=>systemModelMessageSchema),
    "tool": (()=>tool),
    "toolModelMessageSchema": (()=>toolModelMessageSchema),
    "userModelMessageSchema": (()=>userModelMessageSchema),
    "wrapLanguageModel": (()=>wrapLanguageModel)
});
// src/error/invalid-argument-error.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ai-sdk/provider/dist/index.mjs [app-ssr] (ecmascript)");
// src/ui/call-completion-api.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@ai-sdk/provider-utils/dist/index.mjs [app-ssr] (ecmascript) <locals>");
// src/ui-message-stream/ui-message-stream-parts.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/dist/esm/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__ = __turbopack_context__.i("[project]/node_modules/zod/dist/esm/v3/external.js [app-ssr] (ecmascript) <export * as z>");
// core/telemetry/get-tracer.ts
var __TURBOPACK__imported__module__$5b$externals$5d2f40$opentelemetry$2f$api__$5b$external$5d$__$2840$opentelemetry$2f$api$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/@opentelemetry/api [external] (@opentelemetry/api, cjs)");
// core/prompt/resolve-language-model.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$gateway$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@ai-sdk/gateway/dist/index.mjs [app-ssr] (ecmascript)");
var __defProp = Object.defineProperty;
var __export = (target, all)=>{
    for(var name17 in all)__defProp(target, name17, {
        get: all[name17],
        enumerable: true
    });
};
;
;
;
var name = "AI_InvalidArgumentError";
var marker = `vercel.ai.error.${name}`;
var symbol = Symbol.for(marker);
var _a;
var InvalidArgumentError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ parameter, value, message }){
        super({
            name,
            message: `Invalid argument for parameter ${parameter}: ${message}`
        });
        this[_a] = true;
        this.parameter = parameter;
        this.value = value;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker);
    }
};
_a = symbol;
;
var name2 = "AI_InvalidStreamPartError";
var marker2 = `vercel.ai.error.${name2}`;
var symbol2 = Symbol.for(marker2);
var _a2;
var InvalidStreamPartError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ chunk, message }){
        super({
            name: name2,
            message
        });
        this[_a2] = true;
        this.chunk = chunk;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker2);
    }
};
_a2 = symbol2;
;
var name3 = "AI_InvalidToolArgumentsError";
var marker3 = `vercel.ai.error.${name3}`;
var symbol3 = Symbol.for(marker3);
var _a3;
var InvalidToolArgumentsError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ toolArgs, toolName, cause, message = `Invalid arguments for tool ${toolName}: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getErrorMessage"])(cause)}` }){
        super({
            name: name3,
            message,
            cause
        });
        this[_a3] = true;
        this.toolArgs = toolArgs;
        this.toolName = toolName;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker3);
    }
};
_a3 = symbol3;
;
var name4 = "AI_MCPClientError";
var marker4 = `vercel.ai.error.${name4}`;
var symbol4 = Symbol.for(marker4);
var _a4;
var MCPClientError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ name: name17 = "MCPClientError", message, cause }){
        super({
            name: name17,
            message,
            cause
        });
        this[_a4] = true;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker4);
    }
};
_a4 = symbol4;
;
var name5 = "AI_NoImageGeneratedError";
var marker5 = `vercel.ai.error.${name5}`;
var symbol5 = Symbol.for(marker5);
var _a5;
var NoImageGeneratedError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ message = "No image generated.", cause, responses }){
        super({
            name: name5,
            message,
            cause
        });
        this[_a5] = true;
        this.responses = responses;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker5);
    }
};
_a5 = symbol5;
;
var name6 = "AI_NoObjectGeneratedError";
var marker6 = `vercel.ai.error.${name6}`;
var symbol6 = Symbol.for(marker6);
var _a6;
var NoObjectGeneratedError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ message = "No object generated.", cause, text: text2, response, usage, finishReason }){
        super({
            name: name6,
            message,
            cause
        });
        this[_a6] = true;
        this.text = text2;
        this.response = response;
        this.usage = usage;
        this.finishReason = finishReason;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker6);
    }
};
_a6 = symbol6;
;
var name7 = "AI_NoOutputSpecifiedError";
var marker7 = `vercel.ai.error.${name7}`;
var symbol7 = Symbol.for(marker7);
var _a7;
var NoOutputSpecifiedError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    // used in isInstance
    constructor({ message = "No output specified." } = {}){
        super({
            name: name7,
            message
        });
        this[_a7] = true;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker7);
    }
};
_a7 = symbol7;
;
var name8 = "AI_NoSuchToolError";
var marker8 = `vercel.ai.error.${name8}`;
var symbol8 = Symbol.for(marker8);
var _a8;
var NoSuchToolError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? "No tools are available." : `Available tools: ${availableTools.join(", ")}.`}` }){
        super({
            name: name8,
            message
        });
        this[_a8] = true;
        this.toolName = toolName;
        this.availableTools = availableTools;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker8);
    }
};
_a8 = symbol8;
;
var name9 = "AI_ToolCallRepairError";
var marker9 = `vercel.ai.error.${name9}`;
var symbol9 = Symbol.for(marker9);
var _a9;
var ToolCallRepairError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ cause, originalError, message = `Error repairing tool call: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getErrorMessage"])(cause)}` }){
        super({
            name: name9,
            message,
            cause
        });
        this[_a9] = true;
        this.originalError = originalError;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker9);
    }
};
_a9 = symbol9;
;
var name10 = "AI_ToolExecutionError";
var marker10 = `vercel.ai.error.${name10}`;
var symbol10 = Symbol.for(marker10);
var _a10;
var ToolExecutionError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ toolArgs, toolName, toolCallId, cause, message = `Error executing tool ${toolName}: ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getErrorMessage"])(cause)}` }){
        super({
            name: name10,
            message,
            cause
        });
        this[_a10] = true;
        this.toolArgs = toolArgs;
        this.toolName = toolName;
        this.toolCallId = toolCallId;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker10);
    }
};
_a10 = symbol10;
;
var name11 = "AI_InvalidDataContentError";
var marker11 = `vercel.ai.error.${name11}`;
var symbol11 = Symbol.for(marker11);
var _a11;
var InvalidDataContentError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){
        super({
            name: name11,
            message,
            cause
        });
        this[_a11] = true;
        this.content = content;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker11);
    }
};
_a11 = symbol11;
;
var name12 = "AI_InvalidMessageRoleError";
var marker12 = `vercel.ai.error.${name12}`;
var symbol12 = Symbol.for(marker12);
var _a12;
var InvalidMessageRoleError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: "system", "user", "assistant", "tool".` }){
        super({
            name: name12,
            message
        });
        this[_a12] = true;
        this.role = role;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker12);
    }
};
_a12 = symbol12;
;
var name13 = "AI_MessageConversionError";
var marker13 = `vercel.ai.error.${name13}`;
var symbol13 = Symbol.for(marker13);
var _a13;
var MessageConversionError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ originalMessage, message }){
        super({
            name: name13,
            message
        });
        this[_a13] = true;
        this.originalMessage = originalMessage;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker13);
    }
};
_a13 = symbol13;
;
var name14 = "AI_DownloadError";
var marker14 = `vercel.ai.error.${name14}`;
var symbol14 = Symbol.for(marker14);
var _a14;
var DownloadError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){
        super({
            name: name14,
            message,
            cause
        });
        this[_a14] = true;
        this.url = url;
        this.statusCode = statusCode;
        this.statusText = statusText;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker14);
    }
};
_a14 = symbol14;
;
var name15 = "AI_RetryError";
var marker15 = `vercel.ai.error.${name15}`;
var symbol15 = Symbol.for(marker15);
var _a15;
var RetryError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor({ message, reason, errors }){
        super({
            name: name15,
            message
        });
        this[_a15] = true;
        this.reason = reason;
        this.errors = errors;
        this.lastError = errors[errors.length - 1];
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker15);
    }
};
_a15 = symbol15;
// src/util/prepare-headers.ts
function prepareHeaders(headers, defaultHeaders) {
    const responseHeaders = new Headers(headers != null ? headers : {});
    for (const [key, value] of Object.entries(defaultHeaders)){
        if (!responseHeaders.has(key)) {
            responseHeaders.set(key, value);
        }
    }
    return responseHeaders;
}
// src/text-stream/create-text-stream-response.ts
function createTextStreamResponse({ status, statusText, headers, textStream }) {
    return new Response(textStream.pipeThrough(new TextEncoderStream()), {
        status: status != null ? status : 200,
        statusText,
        headers: prepareHeaders(headers, {
            "content-type": "text/plain; charset=utf-8"
        })
    });
}
// src/util/write-to-server-response.ts
function writeToServerResponse({ response, status, statusText, headers, stream }) {
    response.writeHead(status != null ? status : 200, statusText, headers);
    const reader = stream.getReader();
    const read = async ()=>{
        try {
            while(true){
                const { done, value } = await reader.read();
                if (done) break;
                response.write(value);
            }
        } catch (error) {
            throw error;
        } finally{
            response.end();
        }
    };
    read();
}
// src/text-stream/pipe-text-stream-to-response.ts
function pipeTextStreamToResponse({ response, status, statusText, headers, textStream }) {
    writeToServerResponse({
        response,
        status,
        statusText,
        headers: Object.fromEntries(prepareHeaders(headers, {
            "content-type": "text/plain; charset=utf-8"
        }).entries()),
        stream: textStream.pipeThrough(new TextEncoderStream())
    });
}
;
;
var uiMessageStreamPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("error"),
        errorText: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-call-streaming-start"),
        toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-call-delta"),
        toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        argsTextDelta: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-call"),
        toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        args: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-result"),
        toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        result: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
        providerMetadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("reasoning"),
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        providerMetadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any()).optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("source-url"),
        sourceId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        title: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        providerMetadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("source-document"),
        sourceId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        title: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        filename: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        providerMetadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].any().optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file"),
        url: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().startsWith("data-"),
        id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("metadata"),
        value: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
            metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()
        })
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("start-step"),
        metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("finish-step"),
        metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("start"),
        messageId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
        metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("finish"),
        metadata: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown().optional()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("reasoning-part-finish")
    })
]);
function isDataUIMessageStreamPart(part) {
    return part.type.startsWith("data-");
}
// src/util/consume-stream.ts
async function consumeStream({ stream, onError }) {
    const reader = stream.getReader();
    try {
        while(true){
            const { done } = await reader.read();
            if (done) break;
        }
    } catch (error) {
        onError == null ? void 0 : onError(error);
    } finally{
        reader.releaseLock();
    }
}
// src/ui/process-text-stream.ts
async function processTextStream({ stream, onTextPart }) {
    const reader = stream.pipeThrough(new TextDecoderStream()).getReader();
    while(true){
        const { done, value } = await reader.read();
        if (done) {
            break;
        }
        await onTextPart(value);
    }
}
// src/ui/call-completion-api.ts
var getOriginalFetch = ()=>fetch;
async function callCompletionApi({ api, prompt, credentials, headers, body, streamProtocol = "data", setCompletion, setLoading, setError, setAbortController, onFinish, onError, fetch: fetch2 = getOriginalFetch() }) {
    var _a17;
    try {
        setLoading(true);
        setError(void 0);
        const abortController = new AbortController();
        setAbortController(abortController);
        setCompletion("");
        const response = await fetch2(api, {
            method: "POST",
            body: JSON.stringify({
                prompt,
                ...body
            }),
            credentials,
            headers: {
                "Content-Type": "application/json",
                ...headers
            },
            signal: abortController.signal
        }).catch((err)=>{
            throw err;
        });
        if (!response.ok) {
            throw new Error((_a17 = await response.text()) != null ? _a17 : "Failed to fetch the chat response.");
        }
        if (!response.body) {
            throw new Error("The response body is empty.");
        }
        let result = "";
        switch(streamProtocol){
            case "text":
                {
                    await processTextStream({
                        stream: response.body,
                        onTextPart: (chunk)=>{
                            result += chunk;
                            setCompletion(result);
                        }
                    });
                    break;
                }
            case "data":
                {
                    await consumeStream({
                        stream: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parseJsonEventStream"])({
                            stream: response.body,
                            schema: uiMessageStreamPartSchema
                        }).pipeThrough(new TransformStream({
                            async transform (part) {
                                if (!part.success) {
                                    throw part.error;
                                }
                                const streamPart = part.value;
                                if (streamPart.type === "text") {
                                    result += streamPart.text;
                                    setCompletion(result);
                                } else if (streamPart.type === "error") {
                                    throw new Error(streamPart.errorText);
                                }
                            }
                        })),
                        onError: (error)=>{
                            throw error;
                        }
                    });
                    break;
                }
            default:
                {
                    const exhaustiveCheck = streamProtocol;
                    throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);
                }
        }
        if (onFinish) {
            onFinish(prompt, result);
        }
        setAbortController(null);
        return result;
    } catch (err) {
        if (err.name === "AbortError") {
            setAbortController(null);
            return null;
        }
        if (err instanceof Error) {
            if (onError) {
                onError(err);
            }
        }
        setError(err);
    } finally{
        setLoading(false);
    }
}
;
// src/util/serial-job-executor.ts
var SerialJobExecutor = class {
    constructor(){
        this.queue = [];
        this.isProcessing = false;
    }
    async processQueue() {
        if (this.isProcessing) {
            return;
        }
        this.isProcessing = true;
        while(this.queue.length > 0){
            await this.queue[0]();
            this.queue.shift();
        }
        this.isProcessing = false;
    }
    async run(job) {
        return new Promise((resolve, reject)=>{
            this.queue.push(async ()=>{
                try {
                    await job();
                    resolve();
                } catch (error) {
                    reject(error);
                }
            });
            void this.processQueue();
        });
    }
};
// src/ui/convert-file-list-to-file-ui-parts.ts
async function convertFileListToFileUIParts(files) {
    if (files == null) {
        return [];
    }
    if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {
        throw new Error("FileList is not supported in the current environment");
    }
    return Promise.all(Array.from(files).map(async (file)=>{
        const { name: name17, type } = file;
        const dataUrl = await new Promise((resolve, reject)=>{
            const reader = new FileReader();
            reader.onload = (readerEvent)=>{
                var _a17;
                resolve((_a17 = readerEvent.target) == null ? void 0 : _a17.result);
            };
            reader.onerror = (error)=>reject(error);
            reader.readAsDataURL(file);
        });
        return {
            type: "file",
            mediaType: type,
            filename: name17,
            url: dataUrl
        };
    }));
}
;
var getOriginalFetch2 = ()=>fetch;
async function fetchUIMessageStream({ api, body, credentials, headers, abortSignal, fetch: fetch2 = getOriginalFetch2(), requestType = "generate" }) {
    var _a17;
    const response = requestType === "resume" ? await fetch2(`${api}?id=${body.id}`, {
        method: "GET",
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        signal: abortSignal,
        credentials
    }) : await fetch2(api, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        signal: abortSignal,
        credentials
    });
    if (!response.ok) {
        throw new Error((_a17 = await response.text()) != null ? _a17 : "Failed to fetch the chat response.");
    }
    if (!response.body) {
        throw new Error("The response body is empty.");
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parseJsonEventStream"])({
        stream: response.body,
        schema: uiMessageStreamPartSchema
    }).pipeThrough(new TransformStream({
        async transform (part, controller) {
            if (!part.success) {
                throw part.error;
            }
            controller.enqueue(part.value);
        }
    }));
}
var DefaultChatTransport = class {
    constructor({ api = "/api/chat", credentials, headers, body, fetch: fetch2, prepareRequest } = {}){
        this.api = api;
        this.credentials = credentials;
        this.headers = headers;
        this.body = body;
        this.fetch = fetch2;
        this.prepareRequest = prepareRequest;
    }
    submitMessages({ chatId, messages, abortSignal, metadata, headers, body, requestType }) {
        var _a17, _b;
        const preparedRequest = (_a17 = this.prepareRequest) == null ? void 0 : _a17.call(this, {
            id: chatId,
            messages,
            body: {
                ...this.body,
                ...body
            },
            headers: {
                ...this.headers,
                ...headers
            },
            credentials: this.credentials,
            requestMetadata: metadata
        });
        return fetchUIMessageStream({
            api: this.api,
            body: (preparedRequest == null ? void 0 : preparedRequest.body) !== void 0 ? preparedRequest.body : {
                ...this.body,
                ...body,
                id: chatId,
                messages
            },
            headers: (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? preparedRequest.headers : {
                ...this.headers,
                ...headers
            },
            credentials: (_b = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _b : this.credentials,
            abortSignal,
            fetch: this.fetch,
            requestType
        });
    }
};
;
// src/util/merge-objects.ts
function mergeObjects(base, overrides) {
    if (base === void 0 && overrides === void 0) {
        return void 0;
    }
    if (base === void 0) {
        return overrides;
    }
    if (overrides === void 0) {
        return base;
    }
    const result = {
        ...base
    };
    for(const key in overrides){
        if (Object.prototype.hasOwnProperty.call(overrides, key)) {
            const overridesValue = overrides[key];
            if (overridesValue === void 0) continue;
            const baseValue = key in base ? base[key] : void 0;
            const isSourceObject = overridesValue !== null && typeof overridesValue === "object" && !Array.isArray(overridesValue) && !(overridesValue instanceof Date) && !(overridesValue instanceof RegExp);
            const isTargetObject = baseValue !== null && baseValue !== void 0 && typeof baseValue === "object" && !Array.isArray(baseValue) && !(baseValue instanceof Date) && !(baseValue instanceof RegExp);
            if (isSourceObject && isTargetObject) {
                result[key] = mergeObjects(baseValue, overridesValue);
            } else {
                result[key] = overridesValue;
            }
        }
    }
    return result;
}
;
// src/util/fix-json.ts
function fixJson(input) {
    const stack = [
        "ROOT"
    ];
    let lastValidIndex = -1;
    let literalStart = null;
    function processValueStart(char, i, swapState) {
        {
            switch(char){
                case '"':
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_STRING");
                        break;
                    }
                case "f":
                case "t":
                case "n":
                    {
                        lastValidIndex = i;
                        literalStart = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_LITERAL");
                        break;
                    }
                case "-":
                    {
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "0":
                case "1":
                case "2":
                case "3":
                case "4":
                case "5":
                case "6":
                case "7":
                case "8":
                case "9":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_NUMBER");
                        break;
                    }
                case "{":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_OBJECT_START");
                        break;
                    }
                case "[":
                    {
                        lastValidIndex = i;
                        stack.pop();
                        stack.push(swapState);
                        stack.push("INSIDE_ARRAY_START");
                        break;
                    }
            }
        }
    }
    function processAfterObjectValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_OBJECT_AFTER_COMMA");
                    break;
                }
            case "}":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    function processAfterArrayValue(char, i) {
        switch(char){
            case ",":
                {
                    stack.pop();
                    stack.push("INSIDE_ARRAY_AFTER_COMMA");
                    break;
                }
            case "]":
                {
                    lastValidIndex = i;
                    stack.pop();
                    break;
                }
        }
    }
    for(let i = 0; i < input.length; i++){
        const char = input[i];
        const currentState = stack[stack.length - 1];
        switch(currentState){
            case "ROOT":
                processValueStart(char, i, "FINISH");
                break;
            case "INSIDE_OBJECT_START":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                        case "}":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_COMMA":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_KEY":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_AFTER_KEY");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_AFTER_KEY":
                {
                    switch(char){
                        case ":":
                            {
                                stack.pop();
                                stack.push("INSIDE_OBJECT_BEFORE_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_OBJECT_BEFORE_VALUE":
                {
                    processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
                    break;
                }
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    processAfterObjectValue(char, i);
                    break;
                }
            case "INSIDE_STRING":
                {
                    switch(char){
                        case '"':
                            {
                                stack.pop();
                                lastValidIndex = i;
                                break;
                            }
                        case "\\":
                            {
                                stack.push("INSIDE_STRING_ESCAPE");
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_START":
                {
                    switch(char){
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    switch(char){
                        case ",":
                            {
                                stack.pop();
                                stack.push("INSIDE_ARRAY_AFTER_COMMA");
                                break;
                            }
                        case "]":
                            {
                                lastValidIndex = i;
                                stack.pop();
                                break;
                            }
                        default:
                            {
                                lastValidIndex = i;
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_ARRAY_AFTER_COMMA":
                {
                    processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
                    break;
                }
            case "INSIDE_STRING_ESCAPE":
                {
                    stack.pop();
                    lastValidIndex = i;
                    break;
                }
            case "INSIDE_NUMBER":
                {
                    switch(char){
                        case "0":
                        case "1":
                        case "2":
                        case "3":
                        case "4":
                        case "5":
                        case "6":
                        case "7":
                        case "8":
                        case "9":
                            {
                                lastValidIndex = i;
                                break;
                            }
                        case "e":
                        case "E":
                        case "-":
                        case ".":
                            {
                                break;
                            }
                        case ",":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "}":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                                    processAfterObjectValue(char, i);
                                }
                                break;
                            }
                        case "]":
                            {
                                stack.pop();
                                if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                                    processAfterArrayValue(char, i);
                                }
                                break;
                            }
                        default:
                            {
                                stack.pop();
                                break;
                            }
                    }
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, i + 1);
                    if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
                        stack.pop();
                        if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
                            processAfterObjectValue(char, i);
                        } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
                            processAfterArrayValue(char, i);
                        }
                    } else {
                        lastValidIndex = i;
                    }
                    break;
                }
        }
    }
    let result = input.slice(0, lastValidIndex + 1);
    for(let i = stack.length - 1; i >= 0; i--){
        const state = stack[i];
        switch(state){
            case "INSIDE_STRING":
                {
                    result += '"';
                    break;
                }
            case "INSIDE_OBJECT_KEY":
            case "INSIDE_OBJECT_AFTER_KEY":
            case "INSIDE_OBJECT_AFTER_COMMA":
            case "INSIDE_OBJECT_START":
            case "INSIDE_OBJECT_BEFORE_VALUE":
            case "INSIDE_OBJECT_AFTER_VALUE":
                {
                    result += "}";
                    break;
                }
            case "INSIDE_ARRAY_START":
            case "INSIDE_ARRAY_AFTER_COMMA":
            case "INSIDE_ARRAY_AFTER_VALUE":
                {
                    result += "]";
                    break;
                }
            case "INSIDE_LITERAL":
                {
                    const partialLiteral = input.substring(literalStart, input.length);
                    if ("true".startsWith(partialLiteral)) {
                        result += "true".slice(partialLiteral.length);
                    } else if ("false".startsWith(partialLiteral)) {
                        result += "false".slice(partialLiteral.length);
                    } else if ("null".startsWith(partialLiteral)) {
                        result += "null".slice(partialLiteral.length);
                    }
                }
        }
    }
    return result;
}
// src/util/parse-partial-json.ts
async function parsePartialJson(jsonText) {
    if (jsonText === void 0) {
        return {
            value: void 0,
            state: "undefined-input"
        };
    }
    let result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeParseJSON"])({
        text: jsonText
    });
    if (result.success) {
        return {
            value: result.value,
            state: "successful-parse"
        };
    }
    result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeParseJSON"])({
        text: fixJson(jsonText)
    });
    if (result.success) {
        return {
            value: result.value,
            state: "repaired-parse"
        };
    }
    return {
        value: void 0,
        state: "failed-parse"
    };
}
// src/ui/get-tool-invocations.ts
function getToolInvocations(message) {
    return message.parts.filter((part)=>part.type === "tool-invocation").map((part)=>part.toolInvocation);
}
// src/ui/process-ui-message-stream.ts
function createStreamingUIMessageState({ lastMessage, newMessageId = "" } = {}) {
    const isContinuation = (lastMessage == null ? void 0 : lastMessage.role) === "assistant";
    const message = isContinuation ? lastMessage : {
        id: newMessageId,
        metadata: {},
        role: "assistant",
        parts: []
    };
    return {
        message,
        activeTextPart: void 0,
        activeReasoningPart: void 0,
        partialToolCalls: {}
    };
}
function processUIMessageStream({ stream, onToolCall, messageMetadataSchema, dataPartSchemas, runUpdateMessageJob }) {
    return stream.pipeThrough(new TransformStream({
        async transform (part, controller) {
            await runUpdateMessageJob(async ({ state, write })=>{
                function updateToolInvocationPart(toolCallId, invocation) {
                    const part2 = state.message.parts.find((part3)=>isToolInvocationUIPart(part3) && part3.toolInvocation.toolCallId === toolCallId);
                    if (part2 != null) {
                        part2.toolInvocation = invocation;
                    } else {
                        state.message.parts.push({
                            type: "tool-invocation",
                            toolInvocation: invocation
                        });
                    }
                }
                async function updateMessageMetadata(metadata) {
                    if (metadata != null) {
                        const mergedMetadata = state.message.metadata != null ? mergeObjects(state.message.metadata, metadata) : metadata;
                        if (messageMetadataSchema != null) {
                            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["validateTypes"])({
                                value: mergedMetadata,
                                schema: messageMetadataSchema
                            });
                        }
                        state.message.metadata = mergedMetadata;
                    }
                }
                switch(part.type){
                    case "text":
                        {
                            if (state.activeTextPart == null) {
                                state.activeTextPart = {
                                    type: "text",
                                    text: part.text
                                };
                                state.message.parts.push(state.activeTextPart);
                            } else {
                                state.activeTextPart.text += part.text;
                            }
                            write();
                            break;
                        }
                    case "reasoning":
                        {
                            if (state.activeReasoningPart == null) {
                                state.activeReasoningPart = {
                                    type: "reasoning",
                                    text: part.text,
                                    providerMetadata: part.providerMetadata
                                };
                                state.message.parts.push(state.activeReasoningPart);
                            } else {
                                state.activeReasoningPart.text += part.text;
                                state.activeReasoningPart.providerMetadata = part.providerMetadata;
                            }
                            write();
                            break;
                        }
                    case "reasoning-part-finish":
                        {
                            if (state.activeReasoningPart != null) {
                                state.activeReasoningPart = void 0;
                            }
                            break;
                        }
                    case "file":
                        {
                            state.message.parts.push({
                                type: "file",
                                mediaType: part.mediaType,
                                url: part.url
                            });
                            write();
                            break;
                        }
                    case "source-url":
                        {
                            state.message.parts.push({
                                type: "source-url",
                                sourceId: part.sourceId,
                                url: part.url,
                                title: part.title,
                                providerMetadata: part.providerMetadata
                            });
                            write();
                            break;
                        }
                    case "source-document":
                        {
                            state.message.parts.push({
                                type: "source-document",
                                sourceId: part.sourceId,
                                mediaType: part.mediaType,
                                title: part.title,
                                filename: part.filename,
                                providerMetadata: part.providerMetadata
                            });
                            write();
                            break;
                        }
                    case "tool-call-streaming-start":
                        {
                            const toolInvocations = getToolInvocations(state.message);
                            state.partialToolCalls[part.toolCallId] = {
                                text: "",
                                toolName: part.toolName,
                                index: toolInvocations.length
                            };
                            updateToolInvocationPart(part.toolCallId, {
                                state: "partial-call",
                                toolCallId: part.toolCallId,
                                toolName: part.toolName,
                                args: void 0
                            });
                            write();
                            break;
                        }
                    case "tool-call-delta":
                        {
                            const partialToolCall = state.partialToolCalls[part.toolCallId];
                            partialToolCall.text += part.argsTextDelta;
                            const { value: partialArgs } = await parsePartialJson(partialToolCall.text);
                            updateToolInvocationPart(part.toolCallId, {
                                state: "partial-call",
                                toolCallId: part.toolCallId,
                                toolName: partialToolCall.toolName,
                                args: partialArgs
                            });
                            write();
                            break;
                        }
                    case "tool-call":
                        {
                            updateToolInvocationPart(part.toolCallId, {
                                state: "call",
                                toolCallId: part.toolCallId,
                                toolName: part.toolName,
                                args: part.args
                            });
                            write();
                            if (onToolCall) {
                                const result = await onToolCall({
                                    toolCall: part
                                });
                                if (result != null) {
                                    updateToolInvocationPart(part.toolCallId, {
                                        state: "result",
                                        toolCallId: part.toolCallId,
                                        toolName: part.toolName,
                                        args: part.args,
                                        result
                                    });
                                    write();
                                }
                            }
                            break;
                        }
                    case "tool-result":
                        {
                            const toolInvocations = getToolInvocations(state.message);
                            if (toolInvocations == null) {
                                throw new Error("tool_result must be preceded by a tool_call");
                            }
                            const toolInvocationIndex = toolInvocations.findIndex((invocation)=>invocation.toolCallId === part.toolCallId);
                            if (toolInvocationIndex === -1) {
                                throw new Error("tool_result must be preceded by a tool_call with the same toolCallId");
                            }
                            updateToolInvocationPart(part.toolCallId, {
                                ...toolInvocations[toolInvocationIndex],
                                state: "result",
                                result: part.result
                            });
                            write();
                            break;
                        }
                    case "start-step":
                        {
                            state.message.parts.push({
                                type: "step-start"
                            });
                            await updateMessageMetadata(part.metadata);
                            write();
                            break;
                        }
                    case "finish-step":
                        {
                            state.activeTextPart = void 0;
                            state.activeReasoningPart = void 0;
                            await updateMessageMetadata(part.metadata);
                            if (part.metadata != null) {
                                write();
                            }
                            break;
                        }
                    case "start":
                        {
                            if (part.messageId != null) {
                                state.message.id = part.messageId;
                            }
                            await updateMessageMetadata(part.metadata);
                            if (part.messageId != null || part.metadata != null) {
                                write();
                            }
                            break;
                        }
                    case "finish":
                        {
                            await updateMessageMetadata(part.metadata);
                            if (part.metadata != null) {
                                write();
                            }
                            break;
                        }
                    case "metadata":
                        {
                            await updateMessageMetadata(part.metadata);
                            if (part.metadata != null) {
                                write();
                            }
                            break;
                        }
                    case "error":
                        {
                            throw new Error(part.errorText);
                        }
                    default:
                        {
                            if (isDataUIMessageStreamPart(part)) {
                                const existingPart = part.id != null ? state.message.parts.find((partArg)=>part.type === partArg.type && part.id === partArg.id) : void 0;
                                if (existingPart != null) {
                                    existingPart.data = isObject(existingPart.data) && isObject(part.data) ? mergeObjects(existingPart.data, part.data) : part.data;
                                } else {
                                    state.message.parts.push(part);
                                }
                                write();
                            }
                        }
                }
                controller.enqueue(part);
            });
        }
    }));
}
function isToolInvocationUIPart(part) {
    return part.type === "tool-invocation";
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
// src/ui/should-resubmit-messages.ts
function shouldResubmitMessages({ originalMaxToolInvocationStep, originalMessageCount, maxSteps, messages }) {
    const lastMessage = messages[messages.length - 1];
    const lastMessageStepStartCount = lastMessage.parts.filter((part)=>part.type === "step-start").length;
    return(// check if the feature is enabled:
    maxSteps > 1 && // ensure there is a last message:
    lastMessage != null && // ensure we actually have new steps (to prevent infinite loops in case of errors):
    (messages.length > originalMessageCount || lastMessageStepStartCount !== originalMaxToolInvocationStep) && // check that next step is possible:
    isAssistantMessageWithCompletedToolCalls(lastMessage) && // limit the number of automatic steps:
    lastMessageStepStartCount < maxSteps);
}
function isAssistantMessageWithCompletedToolCalls(message) {
    if (!message) {
        return false;
    }
    if (message.role !== "assistant") {
        return false;
    }
    const lastStepStartIndex = message.parts.reduce((lastIndex, part, index)=>{
        return part.type === "step-start" ? index : lastIndex;
    }, -1);
    const lastStepToolInvocations = message.parts.slice(lastStepStartIndex + 1).filter((part)=>part.type === "tool-invocation");
    return lastStepToolInvocations.length > 0 && lastStepToolInvocations.every((part)=>"result" in part.toolInvocation);
}
// src/ui/chat.ts
var AbstractChat = class {
    constructor({ generateId: generateId3 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["generateId"], id = generateId3(), transport = new DefaultChatTransport(), maxSteps = 1, messageMetadataSchema, dataPartSchemas, state, onError, onToolCall, onFinish }){
        this.activeResponse = void 0;
        this.jobExecutor = new SerialJobExecutor();
        this.removeAssistantResponse = ()=>{
            const lastMessage = this.state.messages[this.state.messages.length - 1];
            if (lastMessage == null) {
                throw new Error("Cannot remove assistant response from empty chat");
            }
            if (lastMessage.role !== "assistant") {
                throw new Error("Last message is not an assistant message");
            }
            this.state.popMessage();
        };
        /**
     * Append a user message to the chat list. This triggers the API call to fetch
     * the assistant's response.
     */ this.sendMessage = async (message, options = {})=>{
            var _a17, _b;
            let uiMessage;
            if ("text" in message || "files" in message) {
                const fileParts = Array.isArray(message.files) ? message.files : await convertFileListToFileUIParts(message.files);
                uiMessage = {
                    parts: [
                        ...fileParts,
                        ..."text" in message && message.text != null ? [
                            {
                                type: "text",
                                text: message.text
                            }
                        ] : []
                    ]
                };
            } else {
                uiMessage = message;
            }
            this.state.pushMessage({
                ...uiMessage,
                id: (_a17 = uiMessage.id) != null ? _a17 : this.generateId(),
                role: (_b = uiMessage.role) != null ? _b : "user"
            });
            await this.triggerRequest({
                requestType: "generate",
                ...options
            });
        };
        /**
     * Regenerate the last assistant message.
     */ this.reload = async (options = {})=>{
            if (this.lastMessage === void 0) {
                return;
            }
            if (this.lastMessage.role === "assistant") {
                this.state.popMessage();
            }
            await this.triggerRequest({
                requestType: "generate",
                ...options
            });
        };
        /**
     * Resume an ongoing chat generation stream. This does not resume an aborted generation.
     */ this.experimental_resume = async (options = {})=>{
            await this.triggerRequest({
                requestType: "resume",
                ...options
            });
        };
        this.addToolResult = async ({ toolCallId, result })=>{
            this.jobExecutor.run(async ()=>{
                updateToolCallResult({
                    messages: this.state.messages,
                    toolCallId,
                    toolResult: result
                });
                this.messages = this.state.messages;
                if (this.status === "submitted" || this.status === "streaming") {
                    return;
                }
                const lastMessage = this.lastMessage;
                if (isAssistantMessageWithCompletedToolCalls(lastMessage)) {
                    this.triggerRequest({
                        requestType: "generate"
                    });
                }
            });
        };
        /**
     * Abort the current request immediately, keep the generated tokens if any.
     */ this.stop = async ()=>{
            var _a17;
            if (this.status !== "streaming" && this.status !== "submitted") return;
            if ((_a17 = this.activeResponse) == null ? void 0 : _a17.abortController) {
                this.activeResponse.abortController.abort();
                this.activeResponse.abortController = void 0;
            }
        };
        this.id = id;
        this.maxSteps = maxSteps;
        this.transport = transport;
        this.generateId = generateId3;
        this.messageMetadataSchema = messageMetadataSchema;
        this.dataPartSchemas = dataPartSchemas;
        this.state = state;
        this.onError = onError;
        this.onToolCall = onToolCall;
        this.onFinish = onFinish;
    }
    /**
   * Hook status:
   *
   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.
   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.
   * - `ready`: The full response has been received and processed; a new user message can be submitted.
   * - `error`: An error occurred during the API request, preventing successful completion.
   */ get status() {
        return this.state.status;
    }
    setStatus({ status, error }) {
        if (this.status === status) return;
        this.state.status = status;
        this.state.error = error;
    }
    get error() {
        return this.state.error;
    }
    get messages() {
        return this.state.messages;
    }
    get lastMessage() {
        return this.state.messages[this.state.messages.length - 1];
    }
    set messages(messages) {
        this.state.messages = messages;
    }
    async triggerRequest({ requestType, metadata, headers, body }) {
        var _a17, _b;
        this.setStatus({
            status: "submitted",
            error: void 0
        });
        const messageCount = this.state.messages.length;
        const lastMessage = this.lastMessage;
        const maxStep = (_a17 = lastMessage == null ? void 0 : lastMessage.parts.filter((part)=>part.type === "step-start").length) != null ? _a17 : 0;
        try {
            const activeResponse = {
                state: createStreamingUIMessageState({
                    lastMessage: this.state.snapshot(lastMessage),
                    newMessageId: this.generateId()
                }),
                abortController: new AbortController()
            };
            this.activeResponse = activeResponse;
            const stream = await this.transport.submitMessages({
                chatId: this.id,
                messages: this.state.messages,
                abortSignal: activeResponse.abortController.signal,
                metadata,
                headers,
                body,
                requestType
            });
            const runUpdateMessageJob = (job)=>// serialize the job execution to avoid race conditions:
                this.jobExecutor.run(()=>job({
                        state: activeResponse.state,
                        write: ()=>{
                            var _a18;
                            this.setStatus({
                                status: "streaming"
                            });
                            const replaceLastMessage = activeResponse.state.message.id === ((_a18 = this.lastMessage) == null ? void 0 : _a18.id);
                            if (replaceLastMessage) {
                                this.state.replaceMessage(this.state.messages.length - 1, activeResponse.state.message);
                            } else {
                                this.state.pushMessage(activeResponse.state.message);
                            }
                        }
                    }));
            await consumeStream({
                stream: processUIMessageStream({
                    stream,
                    onToolCall: this.onToolCall,
                    messageMetadataSchema: this.messageMetadataSchema,
                    dataPartSchemas: this.dataPartSchemas,
                    runUpdateMessageJob
                }),
                onError: (error)=>{
                    throw error;
                }
            });
            (_b = this.onFinish) == null ? void 0 : _b.call(this, {
                message: activeResponse.state.message
            });
            this.setStatus({
                status: "ready"
            });
        } catch (err) {
            console.error(err);
            if (err.name === "AbortError") {
                this.setStatus({
                    status: "ready"
                });
                return null;
            }
            if (this.onError && err instanceof Error) {
                this.onError(err);
            }
            this.setStatus({
                status: "error",
                error: err
            });
        } finally{
            this.activeResponse = void 0;
        }
        if (shouldResubmitMessages({
            originalMaxToolInvocationStep: maxStep,
            originalMessageCount: messageCount,
            maxSteps: this.maxSteps,
            messages: this.state.messages
        })) {
            await this.triggerRequest({
                requestType,
                metadata,
                headers,
                body
            });
        }
    }
};
function updateToolCallResult({ messages, toolCallId, toolResult: result }) {
    const lastMessage = messages[messages.length - 1];
    const invocationPart = lastMessage.parts.find((part)=>part.type === "tool-invocation" && part.toolInvocation.toolCallId === toolCallId);
    if (invocationPart == null) {
        return;
    }
    invocationPart.toolInvocation = {
        ...invocationPart.toolInvocation,
        state: "result",
        result
    };
}
// src/ui/convert-to-model-messages.ts
function convertToModelMessages(messages, options) {
    var _a17;
    const tools = (_a17 = options == null ? void 0 : options.tools) != null ? _a17 : {};
    const modelMessages = [];
    for (const message of messages){
        switch(message.role){
            case "system":
                {
                    modelMessages.push({
                        role: "system",
                        content: message.parts.map((part)=>part.type === "text" ? part.text : "").join("")
                    });
                    break;
                }
            case "user":
                {
                    modelMessages.push({
                        role: "user",
                        content: message.parts.filter((part)=>part.type === "text" || part.type === "file").map((part)=>part.type === "file" ? {
                                type: "file",
                                mediaType: part.mediaType,
                                filename: part.filename,
                                data: part.url
                            } : part)
                    });
                    break;
                }
            case "assistant":
                {
                    if (message.parts != null) {
                        let processBlock2 = function() {
                            if (block.length === 0) {
                                return;
                            }
                            const content = [];
                            for (const part of block){
                                switch(part.type){
                                    case "text":
                                        {
                                            content.push(part);
                                            break;
                                        }
                                    case "file":
                                        {
                                            content.push({
                                                type: "file",
                                                mediaType: part.mediaType,
                                                data: part.url
                                            });
                                            break;
                                        }
                                    case "reasoning":
                                        {
                                            content.push({
                                                type: "reasoning",
                                                text: part.text,
                                                providerOptions: part.providerMetadata
                                            });
                                            break;
                                        }
                                    case "tool-invocation":
                                        content.push({
                                            type: "tool-call",
                                            toolCallId: part.toolInvocation.toolCallId,
                                            toolName: part.toolInvocation.toolName,
                                            args: part.toolInvocation.args
                                        });
                                        break;
                                    default:
                                        {
                                            const _exhaustiveCheck = part;
                                            throw new Error(`Unsupported part: ${_exhaustiveCheck}`);
                                        }
                                }
                            }
                            modelMessages.push({
                                role: "assistant",
                                content
                            });
                            const stepInvocations = block.filter((part)=>part.type === "tool-invocation").map((part)=>part.toolInvocation);
                            if (stepInvocations.length > 0) {
                                modelMessages.push({
                                    role: "tool",
                                    content: stepInvocations.map((toolInvocation)=>{
                                        if (!("result" in toolInvocation)) {
                                            throw new MessageConversionError({
                                                originalMessage: message,
                                                message: "ToolInvocation must have a result: " + JSON.stringify(toolInvocation)
                                            });
                                        }
                                        const { toolCallId, toolName, result } = toolInvocation;
                                        const tool2 = tools[toolName];
                                        return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {
                                            type: "tool-result",
                                            toolCallId,
                                            toolName,
                                            result: tool2.experimental_toToolResultContent(result),
                                            experimental_content: tool2.experimental_toToolResultContent(result)
                                        } : {
                                            type: "tool-result",
                                            toolCallId,
                                            toolName,
                                            result
                                        };
                                    })
                                });
                            }
                            block = [];
                        };
                        var processBlock = processBlock2;
                        let block = [];
                        for (const part of message.parts){
                            switch(part.type){
                                case "text":
                                case "reasoning":
                                case "file":
                                case "tool-invocation":
                                    {
                                        block.push(part);
                                        break;
                                    }
                                case "step-start":
                                    {
                                        processBlock2();
                                        break;
                                    }
                            }
                        }
                        processBlock2();
                        break;
                    }
                    break;
                }
            default:
                {
                    const _exhaustiveCheck = message.role;
                    throw new MessageConversionError({
                        originalMessage: message,
                        message: `Unsupported role: ${_exhaustiveCheck}`
                    });
                }
        }
    }
    return modelMessages;
}
var convertToCoreMessages = convertToModelMessages;
// src/ui/transform-text-to-ui-message-stream.ts
function transformTextToUiMessageStream({ stream }) {
    return stream.pipeThrough(new TransformStream({
        start (controller) {
            controller.enqueue({
                type: "start"
            });
            controller.enqueue({
                type: "start-step"
            });
        },
        async transform (part, controller) {
            controller.enqueue({
                type: "text",
                text: part
            });
        },
        async flush (controller) {
            controller.enqueue({
                type: "finish-step"
            });
            controller.enqueue({
                type: "finish"
            });
        }
    }));
}
// src/ui/text-stream-chat-transport.ts
var getOriginalFetch3 = ()=>fetch;
async function fetchTextStream({ api, body, credentials, headers, abortSignal, fetch: fetch2 = getOriginalFetch3(), requestType = "generate" }) {
    var _a17;
    const response = requestType === "resume" ? await fetch2(`${api}?chatId=${body.chatId}`, {
        method: "GET",
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        signal: abortSignal,
        credentials
    }) : await fetch2(api, {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
            "Content-Type": "application/json",
            ...headers
        },
        signal: abortSignal,
        credentials
    });
    if (!response.ok) {
        throw new Error((_a17 = await response.text()) != null ? _a17 : "Failed to fetch the chat response.");
    }
    if (!response.body) {
        throw new Error("The response body is empty.");
    }
    return transformTextToUiMessageStream({
        stream: response.body.pipeThrough(new TextDecoderStream())
    });
}
var TextStreamChatTransport = class {
    constructor({ api, credentials, headers, body, fetch: fetch2, prepareRequest }){
        this.api = api;
        this.credentials = credentials;
        this.headers = headers;
        this.body = body;
        this.fetch = fetch2;
        this.prepareRequest = prepareRequest;
    }
    submitMessages({ chatId, messages, abortSignal, metadata, headers, body, requestType }) {
        var _a17, _b;
        const preparedRequest = (_a17 = this.prepareRequest) == null ? void 0 : _a17.call(this, {
            id: chatId,
            messages,
            body: {
                ...this.body,
                ...body
            },
            headers: {
                ...this.headers,
                ...headers
            },
            credentials: this.credentials,
            requestMetadata: metadata
        });
        return fetchTextStream({
            api: this.api,
            body: (preparedRequest == null ? void 0 : preparedRequest.body) !== void 0 ? preparedRequest.body : {
                ...this.body,
                ...body
            },
            headers: (preparedRequest == null ? void 0 : preparedRequest.headers) !== void 0 ? preparedRequest.headers : {
                ...this.headers,
                ...headers
            },
            credentials: (_b = preparedRequest == null ? void 0 : preparedRequest.credentials) != null ? _b : this.credentials,
            abortSignal,
            fetch: this.fetch,
            requestType
        });
    }
};
// src/ui-message-stream/handle-ui-message-stream-finish.ts
function handleUIMessageStreamFinish({ newMessageId, originalMessages = [], onFinish, stream }) {
    if (onFinish == null) {
        return stream;
    }
    const lastMessage = originalMessages[originalMessages.length - 1];
    const isContinuation = (lastMessage == null ? void 0 : lastMessage.role) === "assistant";
    const messageId = isContinuation ? lastMessage.id : newMessageId;
    const state = createStreamingUIMessageState({
        lastMessage: structuredClone(lastMessage),
        newMessageId: messageId
    });
    const runUpdateMessageJob = async (job)=>{
        await job({
            state,
            write: ()=>{}
        });
    };
    return processUIMessageStream({
        stream,
        runUpdateMessageJob
    }).pipeThrough(new TransformStream({
        transform (chunk, controller) {
            controller.enqueue(chunk);
        },
        flush () {
            const isContinuation2 = state.message.id === (lastMessage == null ? void 0 : lastMessage.id);
            onFinish({
                isContinuation: isContinuation2,
                responseMessage: state.message,
                messages: [
                    ...isContinuation2 ? originalMessages.slice(0, -1) : originalMessages,
                    state.message
                ]
            });
        }
    }));
}
// src/ui-message-stream/create-ui-message-stream.ts
function createUIMessageStream({ execute, onError = ()=>"An error occurred.", // mask error messages for safety by default
originalMessages, onFinish }) {
    let controller;
    const ongoingStreamPromises = [];
    const stream = new ReadableStream({
        start (controllerArg) {
            controller = controllerArg;
        }
    });
    function safeEnqueue(data) {
        try {
            controller.enqueue(data);
        } catch (error) {}
    }
    try {
        const result = execute({
            writer: {
                write (part) {
                    safeEnqueue(part);
                },
                merge (streamArg) {
                    ongoingStreamPromises.push((async ()=>{
                        const reader = streamArg.getReader();
                        while(true){
                            const { done, value } = await reader.read();
                            if (done) break;
                            safeEnqueue(value);
                        }
                    })().catch((error)=>{
                        safeEnqueue({
                            type: "error",
                            errorText: onError(error)
                        });
                    }));
                },
                onError
            }
        });
        if (result) {
            ongoingStreamPromises.push(result.catch((error)=>{
                safeEnqueue({
                    type: "error",
                    errorText: onError(error)
                });
            }));
        }
    } catch (error) {
        safeEnqueue({
            type: "error",
            errorText: onError(error)
        });
    }
    const waitForStreams = new Promise(async (resolve)=>{
        while(ongoingStreamPromises.length > 0){
            await ongoingStreamPromises.shift();
        }
        resolve();
    });
    waitForStreams.finally(()=>{
        try {
            controller.close();
        } catch (error) {}
    });
    return handleUIMessageStreamFinish({
        stream,
        newMessageId: "",
        originalMessages,
        onFinish
    });
}
// src/ui-message-stream/json-to-sse-transform-stream.ts
var JsonToSseTransformStream = class extends TransformStream {
    constructor(){
        super({
            transform (part, controller) {
                controller.enqueue(`data: ${JSON.stringify(part)}

`);
            },
            flush (controller) {
                controller.enqueue("data: [DONE]\n\n");
            }
        });
    }
};
// src/ui-message-stream/ui-message-stream-headers.ts
var uiMessageStreamHeaders = {
    "content-type": "text/event-stream",
    "cache-control": "no-cache",
    connection: "keep-alive",
    "x-vercel-ai-ui-message-stream": "v1",
    "x-accel-buffering": "no"
};
// src/ui-message-stream/create-ui-message-stream-response.ts
function createUIMessageStreamResponse({ status, statusText, headers, stream }) {
    return new Response(stream.pipeThrough(new JsonToSseTransformStream()).pipeThrough(new TextEncoderStream()), {
        status,
        statusText,
        headers: prepareHeaders(headers, uiMessageStreamHeaders)
    });
}
// src/ui-message-stream/pipe-ui-message-stream-to-response.ts
function pipeUIMessageStreamToResponse({ response, status, statusText, headers, stream }) {
    writeToServerResponse({
        response,
        status,
        statusText,
        headers: Object.fromEntries(prepareHeaders(headers, uiMessageStreamHeaders).entries()),
        stream: stream.pipeThrough(new JsonToSseTransformStream()).pipeThrough(new TextEncoderStream())
    });
}
// src/util/cosine-similarity.ts
function cosineSimilarity(vector1, vector2) {
    if (vector1.length !== vector2.length) {
        throw new InvalidArgumentError({
            parameter: "vector1,vector2",
            value: {
                vector1Length: vector1.length,
                vector2Length: vector2.length
            },
            message: `Vectors must have the same length`
        });
    }
    const n = vector1.length;
    if (n === 0) {
        return 0;
    }
    let magnitudeSquared1 = 0;
    let magnitudeSquared2 = 0;
    let dotProduct = 0;
    for(let i = 0; i < n; i++){
        const value1 = vector1[i];
        const value2 = vector2[i];
        magnitudeSquared1 += value1 * value1;
        magnitudeSquared2 += value2 * value2;
        dotProduct += value1 * value2;
    }
    return magnitudeSquared1 === 0 || magnitudeSquared2 === 0 ? 0 : dotProduct / (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));
}
// src/util/data-url.ts
function getTextFromDataUrl(dataUrl) {
    const [header, base64Content] = dataUrl.split(",");
    const mediaType = header.split(";")[0].split(":")[1];
    if (mediaType == null || base64Content == null) {
        throw new Error("Invalid data URL format");
    }
    try {
        return window.atob(base64Content);
    } catch (error) {
        throw new Error(`Error decoding data URL`);
    }
}
// src/util/is-deep-equal-data.ts
function isDeepEqualData(obj1, obj2) {
    if (obj1 === obj2) return true;
    if (obj1 == null || obj2 == null) return false;
    if (typeof obj1 !== "object" && typeof obj2 !== "object") return obj1 === obj2;
    if (obj1.constructor !== obj2.constructor) return false;
    if (obj1 instanceof Date && obj2 instanceof Date) {
        return obj1.getTime() === obj2.getTime();
    }
    if (Array.isArray(obj1)) {
        if (obj1.length !== obj2.length) return false;
        for(let i = 0; i < obj1.length; i++){
            if (!isDeepEqualData(obj1[i], obj2[i])) return false;
        }
        return true;
    }
    const keys1 = Object.keys(obj1);
    const keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) return false;
    for (const key of keys1){
        if (!keys2.includes(key)) return false;
        if (!isDeepEqualData(obj1[key], obj2[key])) return false;
    }
    return true;
}
;
function simulateReadableStream({ chunks, initialDelayInMs = 0, chunkDelayInMs = 0, _internal }) {
    var _a17;
    const delay2 = (_a17 = _internal == null ? void 0 : _internal.delay) != null ? _a17 : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["delay"];
    let index = 0;
    return new ReadableStream({
        async pull (controller) {
            if (index < chunks.length) {
                await delay2(index === 0 ? initialDelayInMs : chunkDelayInMs);
                controller.enqueue(chunks[index++]);
            } else {
                controller.close();
            }
        }
    });
}
;
;
var retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {
            maxRetries,
            delayInMs: initialDelayInMs,
            backoffFactor
        });
async function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {
    try {
        return await f();
    } catch (error) {
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isAbortError"])(error)) {
            throw error;
        }
        if (maxRetries === 0) {
            throw error;
        }
        const errorMessage = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["getErrorMessage"])(error);
        const newErrors = [
            ...errors,
            error
        ];
        const tryNumber = newErrors.length;
        if (tryNumber > maxRetries) {
            throw new RetryError({
                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,
                reason: "maxRetriesExceeded",
                errors: newErrors
            });
        }
        if (error instanceof Error && __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["APICallError"].isInstance(error) && error.isRetryable === true && tryNumber <= maxRetries) {
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["delay"])(delayInMs);
            return _retryWithExponentialBackoff(f, {
                maxRetries,
                delayInMs: backoffFactor * delayInMs,
                backoffFactor
            }, newErrors);
        }
        if (tryNumber === 1) {
            throw error;
        }
        throw new RetryError({
            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,
            reason: "errorNotRetryable",
            errors: newErrors
        });
    }
}
// src/util/prepare-retries.ts
function prepareRetries({ maxRetries }) {
    if (maxRetries != null) {
        if (!Number.isInteger(maxRetries)) {
            throw new InvalidArgumentError({
                parameter: "maxRetries",
                value: maxRetries,
                message: "maxRetries must be an integer"
            });
        }
        if (maxRetries < 0) {
            throw new InvalidArgumentError({
                parameter: "maxRetries",
                value: maxRetries,
                message: "maxRetries must be >= 0"
            });
        }
    }
    const maxRetriesResult = maxRetries != null ? maxRetries : 2;
    return {
        maxRetries: maxRetriesResult,
        retry: retryWithExponentialBackoff({
            maxRetries: maxRetriesResult
        })
    };
}
// core/telemetry/assemble-operation-name.ts
function assembleOperationName({ operationId, telemetry }) {
    return {
        // standardized operation and resource name:
        "operation.name": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : ""}`,
        "resource.name": telemetry == null ? void 0 : telemetry.functionId,
        // detailed, AI SDK specific data:
        "ai.operationId": operationId,
        "ai.telemetry.functionId": telemetry == null ? void 0 : telemetry.functionId
    };
}
// core/telemetry/get-base-telemetry-attributes.ts
function getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {
    var _a17;
    return {
        "ai.model.provider": model.provider,
        "ai.model.id": model.modelId,
        // settings:
        ...Object.entries(settings).reduce((attributes, [key, value])=>{
            attributes[`ai.settings.${key}`] = value;
            return attributes;
        }, {}),
        // add metadata as attributes:
        ...Object.entries((_a17 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a17 : {}).reduce((attributes, [key, value])=>{
            attributes[`ai.telemetry.metadata.${key}`] = value;
            return attributes;
        }, {}),
        // request headers
        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{
            if (value !== void 0) {
                attributes[`ai.request.headers.${key}`] = value;
            }
            return attributes;
        }, {})
    };
}
;
// core/telemetry/noop-tracer.ts
var noopTracer = {
    startSpan () {
        return noopSpan;
    },
    startActiveSpan (name17, arg1, arg2, arg3) {
        if (typeof arg1 === "function") {
            return arg1(noopSpan);
        }
        if (typeof arg2 === "function") {
            return arg2(noopSpan);
        }
        if (typeof arg3 === "function") {
            return arg3(noopSpan);
        }
    }
};
var noopSpan = {
    spanContext () {
        return noopSpanContext;
    },
    setAttribute () {
        return this;
    },
    setAttributes () {
        return this;
    },
    addEvent () {
        return this;
    },
    addLink () {
        return this;
    },
    addLinks () {
        return this;
    },
    setStatus () {
        return this;
    },
    updateName () {
        return this;
    },
    end () {
        return this;
    },
    isRecording () {
        return false;
    },
    recordException () {
        return this;
    }
};
var noopSpanContext = {
    traceId: "",
    spanId: "",
    traceFlags: 0
};
// core/telemetry/get-tracer.ts
function getTracer({ isEnabled = false, tracer } = {}) {
    if (!isEnabled) {
        return noopTracer;
    }
    if (tracer) {
        return tracer;
    }
    return __TURBOPACK__imported__module__$5b$externals$5d2f40$opentelemetry$2f$api__$5b$external$5d$__$2840$opentelemetry$2f$api$2c$__cjs$29$__["trace"].getTracer("ai");
}
;
function recordSpan({ name: name17, tracer, attributes, fn, endWhenDone = true }) {
    return tracer.startActiveSpan(name17, {
        attributes
    }, async (span)=>{
        try {
            const result = await fn(span);
            if (endWhenDone) {
                span.end();
            }
            return result;
        } catch (error) {
            try {
                if (error instanceof Error) {
                    span.recordException({
                        name: error.name,
                        message: error.message,
                        stack: error.stack
                    });
                    span.setStatus({
                        code: __TURBOPACK__imported__module__$5b$externals$5d2f40$opentelemetry$2f$api__$5b$external$5d$__$2840$opentelemetry$2f$api$2c$__cjs$29$__["SpanStatusCode"].ERROR,
                        message: error.message
                    });
                } else {
                    span.setStatus({
                        code: __TURBOPACK__imported__module__$5b$externals$5d2f40$opentelemetry$2f$api__$5b$external$5d$__$2840$opentelemetry$2f$api$2c$__cjs$29$__["SpanStatusCode"].ERROR
                    });
                }
            } finally{
                span.end();
            }
            throw error;
        }
    });
}
// core/telemetry/select-telemetry-attributes.ts
function selectTelemetryAttributes({ telemetry, attributes }) {
    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {
        return {};
    }
    return Object.entries(attributes).reduce((attributes2, [key, value])=>{
        if (value === void 0) {
            return attributes2;
        }
        if (typeof value === "object" && "input" in value && typeof value.input === "function") {
            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {
                return attributes2;
            }
            const result = value.input();
            return result === void 0 ? attributes2 : {
                ...attributes2,
                [key]: result
            };
        }
        if (typeof value === "object" && "output" in value && typeof value.output === "function") {
            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {
                return attributes2;
            }
            const result = value.output();
            return result === void 0 ? attributes2 : {
                ...attributes2,
                [key]: result
            };
        }
        return {
            ...attributes2,
            [key]: value
        };
    }, {});
}
// core/embed/embed.ts
async function embed({ model, value, providerOptions, maxRetries: maxRetriesArg, abortSignal, headers, experimental_telemetry: telemetry }) {
    const { maxRetries, retry } = prepareRetries({
        maxRetries: maxRetriesArg
    });
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
        model,
        telemetry,
        headers,
        settings: {
            maxRetries
        }
    });
    const tracer = getTracer(telemetry);
    return recordSpan({
        name: "ai.embed",
        attributes: selectTelemetryAttributes({
            telemetry,
            attributes: {
                ...assembleOperationName({
                    operationId: "ai.embed",
                    telemetry
                }),
                ...baseTelemetryAttributes,
                "ai.value": {
                    input: ()=>JSON.stringify(value)
                }
            }
        }),
        tracer,
        fn: async (span)=>{
            const { embedding, usage, response } = await retry(()=>// nested spans to align with the embedMany telemetry data:
                recordSpan({
                    name: "ai.embed.doEmbed",
                    attributes: selectTelemetryAttributes({
                        telemetry,
                        attributes: {
                            ...assembleOperationName({
                                operationId: "ai.embed.doEmbed",
                                telemetry
                            }),
                            ...baseTelemetryAttributes,
                            // specific settings that only make sense on the outer level:
                            "ai.values": {
                                input: ()=>[
                                        JSON.stringify(value)
                                    ]
                            }
                        }
                    }),
                    tracer,
                    fn: async (doEmbedSpan)=>{
                        var _a17;
                        const modelResponse = await model.doEmbed({
                            values: [
                                value
                            ],
                            abortSignal,
                            headers,
                            providerOptions
                        });
                        const embedding2 = modelResponse.embeddings[0];
                        const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : {
                            tokens: NaN
                        };
                        doEmbedSpan.setAttributes(selectTelemetryAttributes({
                            telemetry,
                            attributes: {
                                "ai.embeddings": {
                                    output: ()=>modelResponse.embeddings.map((embedding3)=>JSON.stringify(embedding3))
                                },
                                "ai.usage.tokens": usage2.tokens
                            }
                        }));
                        return {
                            embedding: embedding2,
                            usage: usage2,
                            response: modelResponse.response
                        };
                    }
                }));
            span.setAttributes(selectTelemetryAttributes({
                telemetry,
                attributes: {
                    "ai.embedding": {
                        output: ()=>JSON.stringify(embedding)
                    },
                    "ai.usage.tokens": usage.tokens
                }
            }));
            return new DefaultEmbedResult({
                value,
                embedding,
                usage,
                response
            });
        }
    });
}
var DefaultEmbedResult = class {
    constructor(options){
        this.value = options.value;
        this.embedding = options.embedding;
        this.usage = options.usage;
        this.response = options.response;
    }
};
// src/util/split-array.ts
function splitArray(array, chunkSize) {
    if (chunkSize <= 0) {
        throw new Error("chunkSize must be greater than 0");
    }
    const result = [];
    for(let i = 0; i < array.length; i += chunkSize){
        result.push(array.slice(i, i + chunkSize));
    }
    return result;
}
// core/embed/embed-many.ts
async function embedMany({ model, values, maxParallelCalls = Infinity, maxRetries: maxRetriesArg, abortSignal, headers, providerOptions, experimental_telemetry: telemetry }) {
    const { maxRetries, retry } = prepareRetries({
        maxRetries: maxRetriesArg
    });
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
        model,
        telemetry,
        headers,
        settings: {
            maxRetries
        }
    });
    const tracer = getTracer(telemetry);
    return recordSpan({
        name: "ai.embedMany",
        attributes: selectTelemetryAttributes({
            telemetry,
            attributes: {
                ...assembleOperationName({
                    operationId: "ai.embedMany",
                    telemetry
                }),
                ...baseTelemetryAttributes,
                // specific settings that only make sense on the outer level:
                "ai.values": {
                    input: ()=>values.map((value)=>JSON.stringify(value))
                }
            }
        }),
        tracer,
        fn: async (span)=>{
            const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([
                model.maxEmbeddingsPerCall,
                model.supportsParallelCalls
            ]);
            if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {
                const { embeddings: embeddings2, usage, response } = await retry(()=>{
                    return recordSpan({
                        name: "ai.embedMany.doEmbed",
                        attributes: selectTelemetryAttributes({
                            telemetry,
                            attributes: {
                                ...assembleOperationName({
                                    operationId: "ai.embedMany.doEmbed",
                                    telemetry
                                }),
                                ...baseTelemetryAttributes,
                                // specific settings that only make sense on the outer level:
                                "ai.values": {
                                    input: ()=>values.map((value)=>JSON.stringify(value))
                                }
                            }
                        }),
                        tracer,
                        fn: async (doEmbedSpan)=>{
                            var _a17;
                            const modelResponse = await model.doEmbed({
                                values,
                                abortSignal,
                                headers,
                                providerOptions
                            });
                            const embeddings3 = modelResponse.embeddings;
                            const usage2 = (_a17 = modelResponse.usage) != null ? _a17 : {
                                tokens: NaN
                            };
                            doEmbedSpan.setAttributes(selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    "ai.embeddings": {
                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))
                                    },
                                    "ai.usage.tokens": usage2.tokens
                                }
                            }));
                            return {
                                embeddings: embeddings3,
                                usage: usage2,
                                response: modelResponse.response
                            };
                        }
                    });
                });
                span.setAttributes(selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                        "ai.embeddings": {
                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))
                        },
                        "ai.usage.tokens": usage.tokens
                    }
                }));
                return new DefaultEmbedManyResult({
                    values,
                    embeddings: embeddings2,
                    usage,
                    responses: [
                        response
                    ]
                });
            }
            const valueChunks = splitArray(values, maxEmbeddingsPerCall);
            const embeddings = [];
            const responses = [];
            let tokens = 0;
            const parallelChunks = splitArray(valueChunks, supportsParallelCalls ? maxParallelCalls : 1);
            for (const parallelChunk of parallelChunks){
                const results = await Promise.all(parallelChunk.map((chunk)=>{
                    return retry(()=>{
                        return recordSpan({
                            name: "ai.embedMany.doEmbed",
                            attributes: selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    ...assembleOperationName({
                                        operationId: "ai.embedMany.doEmbed",
                                        telemetry
                                    }),
                                    ...baseTelemetryAttributes,
                                    // specific settings that only make sense on the outer level:
                                    "ai.values": {
                                        input: ()=>chunk.map((value)=>JSON.stringify(value))
                                    }
                                }
                            }),
                            tracer,
                            fn: async (doEmbedSpan)=>{
                                var _a17;
                                const modelResponse = await model.doEmbed({
                                    values: chunk,
                                    abortSignal,
                                    headers,
                                    providerOptions
                                });
                                const embeddings2 = modelResponse.embeddings;
                                const usage = (_a17 = modelResponse.usage) != null ? _a17 : {
                                    tokens: NaN
                                };
                                doEmbedSpan.setAttributes(selectTelemetryAttributes({
                                    telemetry,
                                    attributes: {
                                        "ai.embeddings": {
                                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))
                                        },
                                        "ai.usage.tokens": usage.tokens
                                    }
                                }));
                                return {
                                    embeddings: embeddings2,
                                    usage,
                                    response: modelResponse.response
                                };
                            }
                        });
                    });
                }));
                for (const result of results){
                    embeddings.push(...result.embeddings);
                    responses.push(result.response);
                    tokens += result.usage.tokens;
                }
            }
            span.setAttributes(selectTelemetryAttributes({
                telemetry,
                attributes: {
                    "ai.embeddings": {
                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))
                    },
                    "ai.usage.tokens": tokens
                }
            }));
            return new DefaultEmbedManyResult({
                values,
                embeddings,
                usage: {
                    tokens
                },
                responses
            });
        }
    });
}
var DefaultEmbedManyResult = class {
    constructor(options){
        this.values = options.values;
        this.embeddings = options.embeddings;
        this.usage = options.usage;
        this.responses = options.responses;
    }
};
;
var imageMediaTypeSignatures = [
    {
        mediaType: "image/gif",
        bytesPrefix: [
            71,
            73,
            70
        ],
        base64Prefix: "R0lG"
    },
    {
        mediaType: "image/png",
        bytesPrefix: [
            137,
            80,
            78,
            71
        ],
        base64Prefix: "iVBORw"
    },
    {
        mediaType: "image/jpeg",
        bytesPrefix: [
            255,
            216
        ],
        base64Prefix: "/9j/"
    },
    {
        mediaType: "image/webp",
        bytesPrefix: [
            82,
            73,
            70,
            70
        ],
        base64Prefix: "UklGRg"
    },
    {
        mediaType: "image/bmp",
        bytesPrefix: [
            66,
            77
        ],
        base64Prefix: "Qk"
    },
    {
        mediaType: "image/tiff",
        bytesPrefix: [
            73,
            73,
            42,
            0
        ],
        base64Prefix: "SUkqAA"
    },
    {
        mediaType: "image/tiff",
        bytesPrefix: [
            77,
            77,
            0,
            42
        ],
        base64Prefix: "TU0AKg"
    },
    {
        mediaType: "image/avif",
        bytesPrefix: [
            0,
            0,
            0,
            32,
            102,
            116,
            121,
            112,
            97,
            118,
            105,
            102
        ],
        base64Prefix: "AAAAIGZ0eXBhdmlm"
    },
    {
        mediaType: "image/heic",
        bytesPrefix: [
            0,
            0,
            0,
            32,
            102,
            116,
            121,
            112,
            104,
            101,
            105,
            99
        ],
        base64Prefix: "AAAAIGZ0eXBoZWlj"
    }
];
var audioMediaTypeSignatures = [
    {
        mediaType: "audio/mpeg",
        bytesPrefix: [
            255,
            251
        ],
        base64Prefix: "//s="
    },
    {
        mediaType: "audio/wav",
        bytesPrefix: [
            82,
            73,
            70,
            70
        ],
        base64Prefix: "UklGR"
    },
    {
        mediaType: "audio/ogg",
        bytesPrefix: [
            79,
            103,
            103,
            83
        ],
        base64Prefix: "T2dnUw"
    },
    {
        mediaType: "audio/flac",
        bytesPrefix: [
            102,
            76,
            97,
            67
        ],
        base64Prefix: "ZkxhQw"
    },
    {
        mediaType: "audio/aac",
        bytesPrefix: [
            64,
            21,
            0,
            0
        ],
        base64Prefix: "QBUA"
    },
    {
        mediaType: "audio/mp4",
        bytesPrefix: [
            102,
            116,
            121,
            112
        ],
        base64Prefix: "ZnR5cA"
    }
];
var stripID3 = (data)=>{
    const bytes = typeof data === "string" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertBase64ToUint8Array"])(data) : data;
    const id3Size = (bytes[6] & 127) << 21 | (bytes[7] & 127) << 14 | (bytes[8] & 127) << 7 | bytes[9] & 127;
    return bytes.slice(id3Size + 10);
};
function stripID3TagsIfPresent(data) {
    const hasId3 = typeof data === "string" && data.startsWith("SUQz") || typeof data !== "string" && data.length > 10 && data[0] === 73 && // 'I'
    data[1] === 68 && // 'D'
    data[2] === 51;
    return hasId3 ? stripID3(data) : data;
}
function detectMediaType({ data, signatures }) {
    const processedData = stripID3TagsIfPresent(data);
    for (const signature of signatures){
        if (typeof processedData === "string" ? processedData.startsWith(signature.base64Prefix) : processedData.length >= signature.bytesPrefix.length && signature.bytesPrefix.every((byte, index)=>processedData[index] === byte)) {
            return signature.mediaType;
        }
    }
    return void 0;
}
;
var DefaultGeneratedFile = class {
    constructor({ data, mediaType }){
        const isUint8Array = data instanceof Uint8Array;
        this.base64Data = isUint8Array ? void 0 : data;
        this.uint8ArrayData = isUint8Array ? data : void 0;
        this.mediaType = mediaType;
    }
    // lazy conversion with caching to avoid unnecessary conversion overhead:
    get base64() {
        if (this.base64Data == null) {
            this.base64Data = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertUint8ArrayToBase64"])(this.uint8ArrayData);
        }
        return this.base64Data;
    }
    // lazy conversion with caching to avoid unnecessary conversion overhead:
    get uint8Array() {
        if (this.uint8ArrayData == null) {
            this.uint8ArrayData = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertBase64ToUint8Array"])(this.base64Data);
        }
        return this.uint8ArrayData;
    }
};
var DefaultGeneratedFileWithType = class extends DefaultGeneratedFile {
    constructor(options){
        super(options);
        this.type = "file";
    }
};
// core/generate-image/generate-image.ts
async function generateImage({ model, prompt, n = 1, maxImagesPerCall, size, aspectRatio, seed, providerOptions, maxRetries: maxRetriesArg, abortSignal, headers }) {
    var _a17, _b;
    const { retry } = prepareRetries({
        maxRetries: maxRetriesArg
    });
    const maxImagesPerCallWithDefault = (_a17 = maxImagesPerCall != null ? maxImagesPerCall : await invokeModelMaxImagesPerCall(model)) != null ? _a17 : 1;
    const callCount = Math.ceil(n / maxImagesPerCallWithDefault);
    const callImageCounts = Array.from({
        length: callCount
    }, (_, i)=>{
        if (i < callCount - 1) {
            return maxImagesPerCallWithDefault;
        }
        const remainder = n % maxImagesPerCallWithDefault;
        return remainder === 0 ? maxImagesPerCallWithDefault : remainder;
    });
    const results = await Promise.all(callImageCounts.map(async (callImageCount)=>retry(()=>model.doGenerate({
                prompt,
                n: callImageCount,
                abortSignal,
                headers,
                size,
                aspectRatio,
                seed,
                providerOptions: providerOptions != null ? providerOptions : {}
            }))));
    const images = [];
    const warnings = [];
    const responses = [];
    const providerMetadata = {};
    for (const result of results){
        images.push(...result.images.map((image)=>{
            var _a18;
            return new DefaultGeneratedFile({
                data: image,
                mediaType: (_a18 = detectMediaType({
                    data: image,
                    signatures: imageMediaTypeSignatures
                })) != null ? _a18 : "image/png"
            });
        }));
        warnings.push(...result.warnings);
        if (result.providerMetadata) {
            for (const [providerName, metadata] of Object.entries(result.providerMetadata)){
                (_b = providerMetadata[providerName]) != null ? _b : providerMetadata[providerName] = {
                    images: []
                };
                providerMetadata[providerName].images.push(...result.providerMetadata[providerName].images);
            }
        }
        responses.push(result.response);
    }
    if (!images.length) {
        throw new NoImageGeneratedError({
            responses
        });
    }
    return new DefaultGenerateImageResult({
        images,
        warnings,
        responses,
        providerMetadata
    });
}
var DefaultGenerateImageResult = class {
    constructor(options){
        this.images = options.images;
        this.warnings = options.warnings;
        this.responses = options.responses;
        this.providerMetadata = options.providerMetadata;
    }
    get image() {
        return this.images[0];
    }
};
async function invokeModelMaxImagesPerCall(model) {
    const isFunction = model.maxImagesPerCall instanceof Function;
    if (!isFunction) {
        return model.maxImagesPerCall;
    }
    return model.maxImagesPerCall({
        modelId: model.modelId
    });
}
;
;
// core/generate-text/extract-content-text.ts
function extractContentText(content) {
    const parts = content.filter((content2)=>content2.type === "text");
    if (parts.length === 0) {
        return void 0;
    }
    return parts.map((content2)=>content2.text).join("");
}
;
// src/util/download.ts
async function download({ url }) {
    var _a17;
    const urlText = url.toString();
    try {
        const response = await fetch(urlText);
        if (!response.ok) {
            throw new DownloadError({
                url: urlText,
                statusCode: response.status,
                statusText: response.statusText
            });
        }
        return {
            data: new Uint8Array(await response.arrayBuffer()),
            mediaType: (_a17 = response.headers.get("content-type")) != null ? _a17 : void 0
        };
    } catch (error) {
        if (DownloadError.isInstance(error)) {
            throw error;
        }
        throw new DownloadError({
            url: urlText,
            cause: error
        });
    }
}
;
;
;
// core/prompt/split-data-url.ts
function splitDataUrl(dataUrl) {
    try {
        const [header, base64Content] = dataUrl.split(",");
        return {
            mediaType: header.split(";")[0].split(":")[1],
            base64Content
        };
    } catch (error) {
        return {
            mediaType: void 0,
            base64Content: void 0
        };
    }
}
// core/prompt/data-content.ts
var dataContentSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(Uint8Array),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(ArrayBuffer),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].custom(// Buffer might not be available in some environments such as CloudFlare:
    (value)=>{
        var _a17, _b;
        return (_b = (_a17 = globalThis.Buffer) == null ? void 0 : _a17.isBuffer(value)) != null ? _b : false;
    }, {
        message: "Must be a Buffer"
    })
]);
function convertToLanguageModelV2DataContent(content) {
    if (content instanceof Uint8Array) {
        return {
            data: content,
            mediaType: void 0
        };
    }
    if (content instanceof ArrayBuffer) {
        return {
            data: new Uint8Array(content),
            mediaType: void 0
        };
    }
    if (typeof content === "string") {
        try {
            content = new URL(content);
        } catch (error) {}
    }
    if (content instanceof URL && content.protocol === "data:") {
        const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(content.toString());
        if (dataUrlMediaType == null || base64Content == null) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"]({
                name: "InvalidDataContentError",
                message: `Invalid data URL format in content ${content.toString()}`
            });
        }
        return {
            data: base64Content,
            mediaType: dataUrlMediaType
        };
    }
    return {
        data: content,
        mediaType: void 0
    };
}
function convertDataContentToBase64String(content) {
    if (typeof content === "string") {
        return content;
    }
    if (content instanceof ArrayBuffer) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertUint8ArrayToBase64"])(new Uint8Array(content));
    }
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertUint8ArrayToBase64"])(content);
}
function convertDataContentToUint8Array(content) {
    if (content instanceof Uint8Array) {
        return content;
    }
    if (typeof content === "string") {
        try {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["convertBase64ToUint8Array"])(content);
        } catch (error) {
            throw new InvalidDataContentError({
                message: "Invalid data content. Content string is not a base64-encoded media.",
                content,
                cause: error
            });
        }
    }
    if (content instanceof ArrayBuffer) {
        return new Uint8Array(content);
    }
    throw new InvalidDataContentError({
        content
    });
}
// core/prompt/convert-to-language-model-prompt.ts
async function convertToLanguageModelPrompt({ prompt, supportedUrls, downloadImplementation = download }) {
    const downloadedAssets = await downloadAssets(prompt.messages, downloadImplementation, supportedUrls);
    return [
        ...prompt.system != null ? [
            {
                role: "system",
                content: prompt.system
            }
        ] : [],
        ...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedAssets))
    ];
}
function convertToLanguageModelMessage(message, downloadedAssets) {
    const role = message.role;
    switch(role){
        case "system":
            {
                return {
                    role: "system",
                    content: message.content,
                    providerOptions: message.providerOptions
                };
            }
        case "user":
            {
                if (typeof message.content === "string") {
                    return {
                        role: "user",
                        content: [
                            {
                                type: "text",
                                text: message.content
                            }
                        ],
                        providerOptions: message.providerOptions
                    };
                }
                return {
                    role: "user",
                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== "text" || part.text !== ""),
                    providerOptions: message.providerOptions
                };
            }
        case "assistant":
            {
                if (typeof message.content === "string") {
                    return {
                        role: "assistant",
                        content: [
                            {
                                type: "text",
                                text: message.content
                            }
                        ],
                        providerOptions: message.providerOptions
                    };
                }
                return {
                    role: "assistant",
                    content: message.content.filter(// remove empty text parts:
                    (part)=>part.type !== "text" || part.text !== "").map((part)=>{
                        const providerOptions = part.providerOptions;
                        switch(part.type){
                            case "file":
                                {
                                    const { data, mediaType } = convertToLanguageModelV2DataContent(part.data);
                                    return {
                                        type: "file",
                                        data,
                                        filename: part.filename,
                                        mediaType: mediaType != null ? mediaType : part.mediaType,
                                        providerOptions
                                    };
                                }
                            case "reasoning":
                                {
                                    return {
                                        type: "reasoning",
                                        text: part.text,
                                        providerOptions
                                    };
                                }
                            case "text":
                                {
                                    return {
                                        type: "text",
                                        text: part.text,
                                        providerOptions
                                    };
                                }
                            case "tool-call":
                                {
                                    return {
                                        type: "tool-call",
                                        toolCallId: part.toolCallId,
                                        toolName: part.toolName,
                                        args: part.args,
                                        providerOptions
                                    };
                                }
                        }
                    }),
                    providerOptions: message.providerOptions
                };
            }
        case "tool":
            {
                return {
                    role: "tool",
                    content: message.content.map((part)=>({
                            type: "tool-result",
                            toolCallId: part.toolCallId,
                            toolName: part.toolName,
                            result: part.result,
                            content: part.experimental_content,
                            isError: part.isError,
                            providerOptions: part.providerOptions
                        })),
                    providerOptions: message.providerOptions
                };
            }
        default:
            {
                const _exhaustiveCheck = role;
                throw new InvalidMessageRoleError({
                    role: _exhaustiveCheck
                });
            }
    }
}
async function downloadAssets(messages, downloadImplementation, supportedUrls) {
    const urls = messages.filter((message)=>message.role === "user").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === "image" || part.type === "file").map((part)=>{
        var _a17;
        const mediaType = (_a17 = part.mediaType) != null ? _a17 : part.type === "image" ? "image/*" : void 0;
        let data = part.type === "image" ? part.image : part.data;
        if (typeof data === "string") {
            try {
                data = new URL(data);
            } catch (ignored) {}
        }
        return {
            mediaType,
            data
        };
    }).filter((part)=>part.data instanceof URL && part.mediaType != null && !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["isUrlSupported"])({
            url: part.data.toString(),
            mediaType: part.mediaType,
            supportedUrls
        })).map((part)=>part.data);
    const downloadedImages = await Promise.all(urls.map(async (url)=>({
            url,
            data: await downloadImplementation({
                url
            })
        })));
    return Object.fromEntries(downloadedImages.map(({ url, data })=>[
            url.toString(),
            data
        ]));
}
function convertPartToLanguageModelPart(part, downloadedAssets) {
    var _a17, _b;
    if (part.type === "text") {
        return {
            type: "text",
            text: part.text,
            providerOptions: part.providerOptions
        };
    }
    let originalData;
    const type = part.type;
    switch(type){
        case "image":
            originalData = part.image;
            break;
        case "file":
            originalData = part.data;
            break;
        default:
            throw new Error(`Unsupported part type: ${type}`);
    }
    const { data: convertedData, mediaType: convertedMediaType } = convertToLanguageModelV2DataContent(originalData);
    let mediaType = convertedMediaType != null ? convertedMediaType : part.mediaType;
    let data = convertedData;
    if (data instanceof URL) {
        const downloadedFile = downloadedAssets[data.toString()];
        if (downloadedFile) {
            data = downloadedFile.data;
            mediaType = (_a17 = downloadedFile.mediaType) != null ? _a17 : mediaType;
        }
    }
    switch(type){
        case "image":
            {
                if (data instanceof Uint8Array || typeof data === "string") {
                    mediaType = (_b = detectMediaType({
                        data,
                        signatures: imageMediaTypeSignatures
                    })) != null ? _b : mediaType;
                }
                return {
                    type: "file",
                    mediaType: mediaType != null ? mediaType : "image/*",
                    // any image
                    filename: void 0,
                    data,
                    providerOptions: part.providerOptions
                };
            }
        case "file":
            {
                if (mediaType == null) {
                    throw new Error(`Media type is missing for file part`);
                }
                return {
                    type: "file",
                    mediaType,
                    filename: part.filename,
                    data,
                    providerOptions: part.providerOptions
                };
            }
    }
}
// core/prompt/prepare-call-settings.ts
function prepareCallSettings({ maxOutputTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, seed, stopSequences }) {
    if (maxOutputTokens != null) {
        if (!Number.isInteger(maxOutputTokens)) {
            throw new InvalidArgumentError({
                parameter: "maxOutputTokens",
                value: maxOutputTokens,
                message: "maxOutputTokens must be an integer"
            });
        }
        if (maxOutputTokens < 1) {
            throw new InvalidArgumentError({
                parameter: "maxOutputTokens",
                value: maxOutputTokens,
                message: "maxOutputTokens must be >= 1"
            });
        }
    }
    if (temperature != null) {
        if (typeof temperature !== "number") {
            throw new InvalidArgumentError({
                parameter: "temperature",
                value: temperature,
                message: "temperature must be a number"
            });
        }
    }
    if (topP != null) {
        if (typeof topP !== "number") {
            throw new InvalidArgumentError({
                parameter: "topP",
                value: topP,
                message: "topP must be a number"
            });
        }
    }
    if (topK != null) {
        if (typeof topK !== "number") {
            throw new InvalidArgumentError({
                parameter: "topK",
                value: topK,
                message: "topK must be a number"
            });
        }
    }
    if (presencePenalty != null) {
        if (typeof presencePenalty !== "number") {
            throw new InvalidArgumentError({
                parameter: "presencePenalty",
                value: presencePenalty,
                message: "presencePenalty must be a number"
            });
        }
    }
    if (frequencyPenalty != null) {
        if (typeof frequencyPenalty !== "number") {
            throw new InvalidArgumentError({
                parameter: "frequencyPenalty",
                value: frequencyPenalty,
                message: "frequencyPenalty must be a number"
            });
        }
    }
    if (seed != null) {
        if (!Number.isInteger(seed)) {
            throw new InvalidArgumentError({
                parameter: "seed",
                value: seed,
                message: "seed must be an integer"
            });
        }
    }
    return {
        maxOutputTokens,
        temperature,
        topP,
        topK,
        presencePenalty,
        frequencyPenalty,
        stopSequences,
        seed
    };
}
;
var GLOBAL_DEFAULT_PROVIDER = Symbol("vercel.ai.global.defaultProvider");
function resolveLanguageModel(model) {
    if (typeof model !== "string") {
        return model;
    }
    const globalProvider = globalThis[GLOBAL_DEFAULT_PROVIDER];
    return (globalProvider != null ? globalProvider : __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$gateway$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["gateway"]).languageModel(model);
}
;
;
;
;
;
;
var jsonValueSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].lazy(()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].null(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), jsonValueSchema),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(jsonValueSchema)
    ]));
// core/types/provider-metadata.ts
var providerMetadataSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].record(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(), jsonValueSchema));
;
;
var toolResultContentSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
        text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
    }),
    __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image"),
        data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional()
    })
]));
// core/prompt/content-part.ts
var textPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional()
});
var imagePartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image"),
    image: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        dataContentSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(URL)
    ]),
    mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    providerOptions: providerMetadataSchema.optional()
});
var filePartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("file"),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        dataContentSchema,
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].instanceof(URL)
    ]),
    filename: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().optional(),
    mediaType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional()
});
var reasoningPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("reasoning"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional()
});
var toolCallPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-call"),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    args: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    providerOptions: providerMetadataSchema.optional()
});
var toolResultPartSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool-result"),
    toolCallId: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    toolName: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    result: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown(),
    content: toolResultContentSchema.optional(),
    isError: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().optional(),
    providerOptions: providerMetadataSchema.optional()
});
// core/prompt/message.ts
var systemModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("system"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    providerOptions: providerMetadataSchema.optional()
});
var coreSystemMessageSchema = systemModelMessageSchema;
var userModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("user"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            textPartSchema,
            imagePartSchema,
            filePartSchema
        ]))
    ]),
    providerOptions: providerMetadataSchema.optional()
});
var coreUserMessageSchema = userModelMessageSchema;
var assistantModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("assistant"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
            textPartSchema,
            filePartSchema,
            reasoningPartSchema,
            toolCallPartSchema
        ]))
    ]),
    providerOptions: providerMetadataSchema.optional()
});
var coreAssistantMessageSchema = assistantModelMessageSchema;
var toolModelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    role: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("tool"),
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(toolResultPartSchema),
    providerOptions: providerMetadataSchema.optional()
});
var coreToolMessageSchema = toolModelMessageSchema;
var modelMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    systemModelMessageSchema,
    userModelMessageSchema,
    assistantModelMessageSchema,
    toolModelMessageSchema
]);
var coreMessageSchema = modelMessageSchema;
// core/prompt/standardize-prompt.ts
async function standardizePrompt(prompt) {
    if (prompt.prompt == null && prompt.messages == null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidPromptError"]({
            prompt,
            message: "prompt or messages must be defined"
        });
    }
    if (prompt.prompt != null && prompt.messages != null) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidPromptError"]({
            prompt,
            message: "prompt and messages cannot be defined at the same time"
        });
    }
    if (prompt.system != null && typeof prompt.system !== "string") {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidPromptError"]({
            prompt,
            message: "system must be a string"
        });
    }
    let messages;
    if (prompt.prompt != null && typeof prompt.prompt === "string") {
        messages = [
            {
                role: "user",
                content: prompt.prompt
            }
        ];
    } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {
        messages = prompt.prompt;
    } else if (prompt.messages != null) {
        messages = prompt.messages;
    } else {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidPromptError"]({
            prompt,
            message: "prompt or messages must be defined"
        });
    }
    if (messages.length === 0) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidPromptError"]({
            prompt,
            message: "messages must not be empty"
        });
    }
    const validationResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeValidateTypes"])({
        value: messages,
        schema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(modelMessageSchema)
    });
    if (!validationResult.success) {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidPromptError"]({
            prompt,
            message: "The messages must be a ModelMessage[]. If you have passed a UIMessage[], you can use convertToModelMessages to convert them.",
            cause: validationResult.error
        });
    }
    return {
        messages,
        system: prompt.system
    };
}
;
;
function wrapGatewayError(error) {
    if (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$gateway$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GatewayAuthenticationError"].isInstance(error) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$gateway$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GatewayModelNotFoundError"].isInstance(error)) {
        return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"]({
            name: "GatewayError",
            message: "Vercel AI Gateway access failed. If you want to use AI SDK providers directly, use the providers, e.g. @ai-sdk/openai, or register a different global default provider.",
            cause: error
        });
    }
    return error;
}
// core/telemetry/stringify-for-telemetry.ts
function stringifyForTelemetry(prompt) {
    return JSON.stringify(prompt.map((message)=>({
            ...message,
            content: typeof message.content === "string" ? message.content : message.content.map((part)=>part.type === "file" ? {
                    ...part,
                    data: part.data instanceof Uint8Array ? convertDataContentToBase64String(part.data) : part.data
                } : part)
        })));
}
;
;
// src/util/async-iterable-stream.ts
function createAsyncIterableStream(source) {
    const stream = source.pipeThrough(new TransformStream());
    stream[Symbol.asyncIterator] = ()=>{
        const reader = stream.getReader();
        return {
            async next () {
                const { done, value } = await reader.read();
                return done ? {
                    done: true,
                    value: void 0
                } : {
                    done: false,
                    value
                };
            }
        };
    };
    return stream;
}
// core/generate-object/output-strategy.ts
var noSchemaOutputStrategy = {
    type: "no-schema",
    jsonSchema: void 0,
    async validatePartialResult ({ value, textDelta }) {
        return {
            success: true,
            value: {
                partial: value,
                textDelta
            }
        };
    },
    async validateFinalResult (value, context) {
        return value === void 0 ? {
            success: false,
            error: new NoObjectGeneratedError({
                message: "No object generated: response did not match schema.",
                text: context.text,
                response: context.response,
                usage: context.usage,
                finishReason: context.finishReason
            })
        } : {
            success: true,
            value
        };
    },
    createElementStream () {
        throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsupportedFunctionalityError"]({
            functionality: "element streams in no-schema mode"
        });
    }
};
var objectOutputStrategy = (schema)=>({
        type: "object",
        jsonSchema: schema.jsonSchema,
        async validatePartialResult ({ value, textDelta }) {
            return {
                success: true,
                value: {
                    // Note: currently no validation of partial results:
                    partial: value,
                    textDelta
                }
            };
        },
        async validateFinalResult (value) {
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeValidateTypes"])({
                value,
                schema
            });
        },
        createElementStream () {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsupportedFunctionalityError"]({
                functionality: "element streams in object mode"
            });
        }
    });
var arrayOutputStrategy = (schema)=>{
    const { $schema, ...itemSchema } = schema.jsonSchema;
    return {
        type: "enum",
        // wrap in object that contains array of elements, since most LLMs will not
        // be able to generate an array directly:
        // possible future optimization: use arrays directly when model supports grammar-guided generation
        jsonSchema: {
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            properties: {
                elements: {
                    type: "array",
                    items: itemSchema
                }
            },
            required: [
                "elements"
            ],
            additionalProperties: false
        },
        async validatePartialResult ({ value, latestObject, isFirstDelta, isFinalDelta }) {
            var _a17;
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isJSONObject"])(value) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isJSONArray"])(value.elements)) {
                return {
                    success: false,
                    error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeValidationError"]({
                        value,
                        cause: "value must be an object that contains an array of elements"
                    })
                };
            }
            const inputArray = value.elements;
            const resultArray = [];
            for(let i = 0; i < inputArray.length; i++){
                const element = inputArray[i];
                const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeValidateTypes"])({
                    value: element,
                    schema
                });
                if (i === inputArray.length - 1 && !isFinalDelta) {
                    continue;
                }
                if (!result.success) {
                    return result;
                }
                resultArray.push(result.value);
            }
            const publishedElementCount = (_a17 = latestObject == null ? void 0 : latestObject.length) != null ? _a17 : 0;
            let textDelta = "";
            if (isFirstDelta) {
                textDelta += "[";
            }
            if (publishedElementCount > 0) {
                textDelta += ",";
            }
            textDelta += resultArray.slice(publishedElementCount).map((element)=>JSON.stringify(element)).join(",");
            if (isFinalDelta) {
                textDelta += "]";
            }
            return {
                success: true,
                value: {
                    partial: resultArray,
                    textDelta
                }
            };
        },
        async validateFinalResult (value) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isJSONObject"])(value) || !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isJSONArray"])(value.elements)) {
                return {
                    success: false,
                    error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeValidationError"]({
                        value,
                        cause: "value must be an object that contains an array of elements"
                    })
                };
            }
            const inputArray = value.elements;
            for (const element of inputArray){
                const result = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeValidateTypes"])({
                    value: element,
                    schema
                });
                if (!result.success) {
                    return result;
                }
            }
            return {
                success: true,
                value: inputArray
            };
        },
        createElementStream (originalStream) {
            let publishedElements = 0;
            return createAsyncIterableStream(originalStream.pipeThrough(new TransformStream({
                transform (chunk, controller) {
                    switch(chunk.type){
                        case "object":
                            {
                                const array = chunk.object;
                                for(; publishedElements < array.length; publishedElements++){
                                    controller.enqueue(array[publishedElements]);
                                }
                                break;
                            }
                        case "text-delta":
                        case "finish":
                        case "error":
                            break;
                        default:
                            {
                                const _exhaustiveCheck = chunk;
                                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
                            }
                    }
                }
            })));
        }
    };
};
var enumOutputStrategy = (enumValues)=>{
    return {
        type: "enum",
        // wrap in object that contains result, since most LLMs will not
        // be able to generate an enum value directly:
        // possible future optimization: use enums directly when model supports top-level enums
        jsonSchema: {
            $schema: "http://json-schema.org/draft-07/schema#",
            type: "object",
            properties: {
                result: {
                    type: "string",
                    enum: enumValues
                }
            },
            required: [
                "result"
            ],
            additionalProperties: false
        },
        async validateFinalResult (value) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isJSONObject"])(value) || typeof value.result !== "string") {
                return {
                    success: false,
                    error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeValidationError"]({
                        value,
                        cause: 'value must be an object that contains a string in the "result" property.'
                    })
                };
            }
            const result = value.result;
            return enumValues.includes(result) ? {
                success: true,
                value: result
            } : {
                success: false,
                error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeValidationError"]({
                    value,
                    cause: "value must be a string in the enum"
                })
            };
        },
        async validatePartialResult ({ value, textDelta }) {
            if (!(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isJSONObject"])(value) || typeof value.result !== "string") {
                return {
                    success: false,
                    error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeValidationError"]({
                        value,
                        cause: 'value must be an object that contains a string in the "result" property.'
                    })
                };
            }
            const result = value.result;
            const possibleEnumValues = enumValues.filter((enumValue)=>enumValue.startsWith(result));
            if (value.result.length === 0 || possibleEnumValues.length === 0) {
                return {
                    success: false,
                    error: new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeValidationError"]({
                        value,
                        cause: "value must be a string in the enum"
                    })
                };
            }
            return {
                success: true,
                value: {
                    partial: possibleEnumValues.length > 1 ? result : possibleEnumValues[0],
                    textDelta
                }
            };
        },
        createElementStream () {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["UnsupportedFunctionalityError"]({
                functionality: "element streams in enum mode"
            });
        }
    };
};
function getOutputStrategy({ output, schema, enumValues }) {
    switch(output){
        case "object":
            return objectOutputStrategy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["asSchema"])(schema));
        case "array":
            return arrayOutputStrategy((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["asSchema"])(schema));
        case "enum":
            return enumOutputStrategy(enumValues);
        case "no-schema":
            return noSchemaOutputStrategy;
        default:
            {
                const _exhaustiveCheck = output;
                throw new Error(`Unsupported output: ${_exhaustiveCheck}`);
            }
    }
}
// core/generate-object/validate-object-generation-input.ts
function validateObjectGenerationInput({ output, schema, schemaName, schemaDescription, enumValues }) {
    if (output != null && output !== "object" && output !== "array" && output !== "enum" && output !== "no-schema") {
        throw new InvalidArgumentError({
            parameter: "output",
            value: output,
            message: "Invalid output type."
        });
    }
    if (output === "no-schema") {
        if (schema != null) {
            throw new InvalidArgumentError({
                parameter: "schema",
                value: schema,
                message: "Schema is not supported for no-schema output."
            });
        }
        if (schemaDescription != null) {
            throw new InvalidArgumentError({
                parameter: "schemaDescription",
                value: schemaDescription,
                message: "Schema description is not supported for no-schema output."
            });
        }
        if (schemaName != null) {
            throw new InvalidArgumentError({
                parameter: "schemaName",
                value: schemaName,
                message: "Schema name is not supported for no-schema output."
            });
        }
        if (enumValues != null) {
            throw new InvalidArgumentError({
                parameter: "enumValues",
                value: enumValues,
                message: "Enum values are not supported for no-schema output."
            });
        }
    }
    if (output === "object") {
        if (schema == null) {
            throw new InvalidArgumentError({
                parameter: "schema",
                value: schema,
                message: "Schema is required for object output."
            });
        }
        if (enumValues != null) {
            throw new InvalidArgumentError({
                parameter: "enumValues",
                value: enumValues,
                message: "Enum values are not supported for object output."
            });
        }
    }
    if (output === "array") {
        if (schema == null) {
            throw new InvalidArgumentError({
                parameter: "schema",
                value: schema,
                message: "Element schema is required for array output."
            });
        }
        if (enumValues != null) {
            throw new InvalidArgumentError({
                parameter: "enumValues",
                value: enumValues,
                message: "Enum values are not supported for array output."
            });
        }
    }
    if (output === "enum") {
        if (schema != null) {
            throw new InvalidArgumentError({
                parameter: "schema",
                value: schema,
                message: "Schema is not supported for enum output."
            });
        }
        if (schemaDescription != null) {
            throw new InvalidArgumentError({
                parameter: "schemaDescription",
                value: schemaDescription,
                message: "Schema description is not supported for enum output."
            });
        }
        if (schemaName != null) {
            throw new InvalidArgumentError({
                parameter: "schemaName",
                value: schemaName,
                message: "Schema name is not supported for enum output."
            });
        }
        if (enumValues == null) {
            throw new InvalidArgumentError({
                parameter: "enumValues",
                value: enumValues,
                message: "Enum values are required for enum output."
            });
        }
        for (const value of enumValues){
            if (typeof value !== "string") {
                throw new InvalidArgumentError({
                    parameter: "enumValues",
                    value,
                    message: "Enum values must be strings."
                });
            }
        }
    }
}
// core/generate-object/generate-object.ts
var originalGenerateId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createIdGenerator"])({
    prefix: "aiobj",
    size: 24
});
async function generateObject(options) {
    const { model: modelArg, output = "object", system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, headers, experimental_repairText: repairText, experimental_telemetry: telemetry, providerOptions, _internal: { generateId: generateId3 = originalGenerateId, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings } = options;
    const model = resolveLanguageModel(modelArg);
    const enumValues = "enum" in options ? options.enum : void 0;
    const { schema: inputSchema, schemaDescription, schemaName } = "schema" in options ? options : {};
    validateObjectGenerationInput({
        output,
        schema: inputSchema,
        schemaName,
        schemaDescription,
        enumValues
    });
    const { maxRetries, retry } = prepareRetries({
        maxRetries: maxRetriesArg
    });
    const outputStrategy = getOutputStrategy({
        output,
        schema: inputSchema,
        enumValues
    });
    const callSettings = prepareCallSettings(settings);
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
        model,
        telemetry,
        headers,
        settings: {
            ...callSettings,
            maxRetries
        }
    });
    const tracer = getTracer(telemetry);
    try {
        return await recordSpan({
            name: "ai.generateObject",
            attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                    ...assembleOperationName({
                        operationId: "ai.generateObject",
                        telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // specific settings that only make sense on the outer level:
                    "ai.prompt": {
                        input: ()=>JSON.stringify({
                                system,
                                prompt,
                                messages
                            })
                    },
                    "ai.schema": outputStrategy.jsonSchema != null ? {
                        input: ()=>JSON.stringify(outputStrategy.jsonSchema)
                    } : void 0,
                    "ai.schema.name": schemaName,
                    "ai.schema.description": schemaDescription,
                    "ai.settings.output": outputStrategy.type
                }
            }),
            tracer,
            fn: async (span)=>{
                var _a17;
                let result;
                let finishReason;
                let usage;
                let warnings;
                let response;
                let request;
                let resultProviderMetadata;
                const standardizedPrompt = await standardizePrompt({
                    system,
                    prompt,
                    messages
                });
                const promptMessages = await convertToLanguageModelPrompt({
                    prompt: standardizedPrompt,
                    supportedUrls: await model.supportedUrls
                });
                const generateResult = await retry(()=>recordSpan({
                        name: "ai.generateObject.doGenerate",
                        attributes: selectTelemetryAttributes({
                            telemetry,
                            attributes: {
                                ...assembleOperationName({
                                    operationId: "ai.generateObject.doGenerate",
                                    telemetry
                                }),
                                ...baseTelemetryAttributes,
                                "ai.prompt.messages": {
                                    input: ()=>stringifyForTelemetry(promptMessages)
                                },
                                // standardized gen-ai llm span attributes:
                                "gen_ai.system": model.provider,
                                "gen_ai.request.model": model.modelId,
                                "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                                "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                                "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                                "gen_ai.request.temperature": callSettings.temperature,
                                "gen_ai.request.top_k": callSettings.topK,
                                "gen_ai.request.top_p": callSettings.topP
                            }
                        }),
                        tracer,
                        fn: async (span2)=>{
                            var _a18, _b, _c, _d, _e, _f, _g, _h;
                            const result2 = await model.doGenerate({
                                responseFormat: {
                                    type: "json",
                                    schema: outputStrategy.jsonSchema,
                                    name: schemaName,
                                    description: schemaDescription
                                },
                                ...prepareCallSettings(settings),
                                prompt: promptMessages,
                                providerOptions,
                                abortSignal,
                                headers
                            });
                            const responseData = {
                                id: (_b = (_a18 = result2.response) == null ? void 0 : _a18.id) != null ? _b : generateId3(),
                                timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),
                                modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId,
                                headers: (_g = result2.response) == null ? void 0 : _g.headers,
                                body: (_h = result2.response) == null ? void 0 : _h.body
                            };
                            const text2 = extractContentText(result2.content);
                            if (text2 === void 0) {
                                throw new NoObjectGeneratedError({
                                    message: "No object generated: the model did not return a response.",
                                    response: responseData,
                                    usage: result2.usage,
                                    finishReason: result2.finishReason
                                });
                            }
                            span2.setAttributes(selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    "ai.response.finishReason": result2.finishReason,
                                    "ai.response.object": {
                                        output: ()=>text2
                                    },
                                    "ai.response.id": responseData.id,
                                    "ai.response.model": responseData.modelId,
                                    "ai.response.timestamp": responseData.timestamp.toISOString(),
                                    // TODO rename telemetry attributes to inputTokens and outputTokens
                                    "ai.usage.promptTokens": result2.usage.inputTokens,
                                    "ai.usage.completionTokens": result2.usage.outputTokens,
                                    // standardized gen-ai llm span attributes:
                                    "gen_ai.response.finish_reasons": [
                                        result2.finishReason
                                    ],
                                    "gen_ai.response.id": responseData.id,
                                    "gen_ai.response.model": responseData.modelId,
                                    "gen_ai.usage.input_tokens": result2.usage.inputTokens,
                                    "gen_ai.usage.output_tokens": result2.usage.outputTokens
                                }
                            }));
                            return {
                                ...result2,
                                objectText: text2,
                                responseData
                            };
                        }
                    }));
                result = generateResult.objectText;
                finishReason = generateResult.finishReason;
                usage = generateResult.usage;
                warnings = generateResult.warnings;
                resultProviderMetadata = generateResult.providerMetadata;
                request = (_a17 = generateResult.request) != null ? _a17 : {};
                response = generateResult.responseData;
                async function processResult(result2) {
                    const parseResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeParseJSON"])({
                        text: result2
                    });
                    if (!parseResult.success) {
                        throw new NoObjectGeneratedError({
                            message: "No object generated: could not parse the response.",
                            cause: parseResult.error,
                            text: result2,
                            response,
                            usage,
                            finishReason
                        });
                    }
                    const validationResult = await outputStrategy.validateFinalResult(parseResult.value, {
                        text: result2,
                        response,
                        usage
                    });
                    if (!validationResult.success) {
                        throw new NoObjectGeneratedError({
                            message: "No object generated: response did not match schema.",
                            cause: validationResult.error,
                            text: result2,
                            response,
                            usage,
                            finishReason
                        });
                    }
                    return validationResult.value;
                }
                let object2;
                try {
                    object2 = await processResult(result);
                } catch (error) {
                    if (repairText != null && NoObjectGeneratedError.isInstance(error) && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["JSONParseError"].isInstance(error.cause) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TypeValidationError"].isInstance(error.cause))) {
                        const repairedText = await repairText({
                            text: result,
                            error: error.cause
                        });
                        if (repairedText === null) {
                            throw error;
                        }
                        object2 = await processResult(repairedText);
                    } else {
                        throw error;
                    }
                }
                span.setAttributes(selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                        "ai.response.finishReason": finishReason,
                        "ai.response.object": {
                            output: ()=>JSON.stringify(object2)
                        },
                        // TODO rename telemetry attributes to inputTokens and outputTokens
                        "ai.usage.promptTokens": usage.inputTokens,
                        "ai.usage.completionTokens": usage.outputTokens
                    }
                }));
                return new DefaultGenerateObjectResult({
                    object: object2,
                    finishReason,
                    usage,
                    warnings,
                    request,
                    response,
                    providerMetadata: resultProviderMetadata
                });
            }
        });
    } catch (error) {
        throw wrapGatewayError(error);
    }
}
var DefaultGenerateObjectResult = class {
    constructor(options){
        this.object = options.object;
        this.finishReason = options.finishReason;
        this.usage = options.usage;
        this.warnings = options.warnings;
        this.providerMetadata = options.providerMetadata;
        this.response = options.response;
        this.request = options.request;
    }
    toJsonResponse(init) {
        var _a17;
        return new Response(JSON.stringify(this.object), {
            status: (_a17 = init == null ? void 0 : init.status) != null ? _a17 : 200,
            headers: prepareHeaders(init == null ? void 0 : init.headers, {
                "content-type": "application/json; charset=utf-8"
            })
        });
    }
};
;
// src/util/create-resolvable-promise.ts
function createResolvablePromise() {
    let resolve;
    let reject;
    const promise = new Promise((res, rej)=>{
        resolve = res;
        reject = rej;
    });
    return {
        promise,
        resolve,
        reject
    };
}
// src/util/create-stitchable-stream.ts
function createStitchableStream() {
    let innerStreamReaders = [];
    let controller = null;
    let isClosed = false;
    let waitForNewStream = createResolvablePromise();
    const processPull = async ()=>{
        if (isClosed && innerStreamReaders.length === 0) {
            controller == null ? void 0 : controller.close();
            return;
        }
        if (innerStreamReaders.length === 0) {
            waitForNewStream = createResolvablePromise();
            await waitForNewStream.promise;
            return processPull();
        }
        try {
            const { value, done } = await innerStreamReaders[0].read();
            if (done) {
                innerStreamReaders.shift();
                if (innerStreamReaders.length > 0) {
                    await processPull();
                } else if (isClosed) {
                    controller == null ? void 0 : controller.close();
                }
            } else {
                controller == null ? void 0 : controller.enqueue(value);
            }
        } catch (error) {
            controller == null ? void 0 : controller.error(error);
            innerStreamReaders.shift();
            if (isClosed && innerStreamReaders.length === 0) {
                controller == null ? void 0 : controller.close();
            }
        }
    };
    return {
        stream: new ReadableStream({
            start (controllerParam) {
                controller = controllerParam;
            },
            pull: processPull,
            async cancel () {
                for (const reader of innerStreamReaders){
                    await reader.cancel();
                }
                innerStreamReaders = [];
                isClosed = true;
            }
        }),
        addStream: (innerStream)=>{
            if (isClosed) {
                throw new Error("Cannot add inner stream: outer stream is closed");
            }
            innerStreamReaders.push(innerStream.getReader());
            waitForNewStream.resolve();
        },
        /**
     * Gracefully close the outer stream. This will let the inner streams
     * finish processing and then close the outer stream.
     */ close: ()=>{
            isClosed = true;
            waitForNewStream.resolve();
            if (innerStreamReaders.length === 0) {
                controller == null ? void 0 : controller.close();
            }
        },
        /**
     * Immediately close the outer stream. This will cancel all inner streams
     * and close the outer stream.
     */ terminate: ()=>{
            isClosed = true;
            waitForNewStream.resolve();
            innerStreamReaders.forEach((reader)=>reader.cancel());
            innerStreamReaders = [];
            controller == null ? void 0 : controller.close();
        }
    };
}
// src/util/delayed-promise.ts
var DelayedPromise = class {
    constructor(){
        this.status = {
            type: "pending"
        };
        this._resolve = void 0;
        this._reject = void 0;
    }
    get promise() {
        if (this._promise) {
            return this._promise;
        }
        this._promise = new Promise((resolve, reject)=>{
            if (this.status.type === "resolved") {
                resolve(this.status.value);
            } else if (this.status.type === "rejected") {
                reject(this.status.error);
            }
            this._resolve = resolve;
            this._reject = reject;
        });
        return this._promise;
    }
    resolve(value) {
        var _a17;
        this.status = {
            type: "resolved",
            value
        };
        if (this._promise) {
            (_a17 = this._resolve) == null ? void 0 : _a17.call(this, value);
        }
    }
    reject(error) {
        var _a17;
        this.status = {
            type: "rejected",
            error
        };
        if (this._promise) {
            (_a17 = this._reject) == null ? void 0 : _a17.call(this, error);
        }
    }
};
// src/util/now.ts
function now() {
    var _a17, _b;
    return (_b = (_a17 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a17.now()) != null ? _b : Date.now();
}
// core/generate-object/stream-object.ts
var originalGenerateId2 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createIdGenerator"])({
    prefix: "aiobj",
    size: 24
});
function streamObject(options) {
    const { model, output = "object", system, prompt, messages, maxRetries, abortSignal, headers, experimental_telemetry: telemetry, providerOptions, onError = ({ error })=>{
        console.error(error);
    }, onFinish, _internal: { generateId: generateId3 = originalGenerateId2, currentDate = ()=>/* @__PURE__ */ new Date(), now: now2 = now } = {}, ...settings } = options;
    const enumValues = "enum" in options && options.enum ? options.enum : void 0;
    const { schema: inputSchema, schemaDescription, schemaName } = "schema" in options ? options : {};
    validateObjectGenerationInput({
        output,
        schema: inputSchema,
        schemaName,
        schemaDescription,
        enumValues
    });
    const outputStrategy = getOutputStrategy({
        output,
        schema: inputSchema,
        enumValues
    });
    return new DefaultStreamObjectResult({
        model,
        telemetry,
        headers,
        settings,
        maxRetries,
        abortSignal,
        outputStrategy,
        system,
        prompt,
        messages,
        schemaName,
        schemaDescription,
        providerOptions,
        onError,
        onFinish,
        generateId: generateId3,
        currentDate,
        now: now2
    });
}
var DefaultStreamObjectResult = class {
    constructor({ model: modelArg, headers, telemetry, settings, maxRetries: maxRetriesArg, abortSignal, outputStrategy, system, prompt, messages, schemaName, schemaDescription, providerOptions, onError, onFinish, generateId: generateId3, currentDate, now: now2 }){
        this._object = new DelayedPromise();
        this._usage = new DelayedPromise();
        this._providerMetadata = new DelayedPromise();
        this._warnings = new DelayedPromise();
        this._request = new DelayedPromise();
        this._response = new DelayedPromise();
        const model = resolveLanguageModel(modelArg);
        const { maxRetries, retry } = prepareRetries({
            maxRetries: maxRetriesArg
        });
        const callSettings = prepareCallSettings(settings);
        const baseTelemetryAttributes = getBaseTelemetryAttributes({
            model,
            telemetry,
            headers,
            settings: {
                ...callSettings,
                maxRetries
            }
        });
        const tracer = getTracer(telemetry);
        const self = this;
        const stitchableStream = createStitchableStream();
        const eventProcessor = new TransformStream({
            transform (chunk, controller) {
                controller.enqueue(chunk);
                if (chunk.type === "error") {
                    onError({
                        error: wrapGatewayError(chunk.error)
                    });
                }
            }
        });
        this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);
        recordSpan({
            name: "ai.streamObject",
            attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                    ...assembleOperationName({
                        operationId: "ai.streamObject",
                        telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // specific settings that only make sense on the outer level:
                    "ai.prompt": {
                        input: ()=>JSON.stringify({
                                system,
                                prompt,
                                messages
                            })
                    },
                    "ai.schema": outputStrategy.jsonSchema != null ? {
                        input: ()=>JSON.stringify(outputStrategy.jsonSchema)
                    } : void 0,
                    "ai.schema.name": schemaName,
                    "ai.schema.description": schemaDescription,
                    "ai.settings.output": outputStrategy.type
                }
            }),
            tracer,
            endWhenDone: false,
            fn: async (rootSpan)=>{
                const standardizedPrompt = await standardizePrompt({
                    system,
                    prompt,
                    messages
                });
                const callOptions = {
                    responseFormat: {
                        type: "json",
                        schema: outputStrategy.jsonSchema,
                        name: schemaName,
                        description: schemaDescription
                    },
                    ...prepareCallSettings(settings),
                    prompt: await convertToLanguageModelPrompt({
                        prompt: standardizedPrompt,
                        supportedUrls: await model.supportedUrls
                    }),
                    providerOptions,
                    abortSignal,
                    headers,
                    includeRawChunks: false
                };
                const transformer = {
                    transform: (chunk, controller)=>{
                        switch(chunk.type){
                            case "text":
                                controller.enqueue(chunk.text);
                                break;
                            case "response-metadata":
                            case "finish":
                            case "error":
                                controller.enqueue(chunk);
                                break;
                        }
                    }
                };
                const { result: { stream, response, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({
                        name: "ai.streamObject.doStream",
                        attributes: selectTelemetryAttributes({
                            telemetry,
                            attributes: {
                                ...assembleOperationName({
                                    operationId: "ai.streamObject.doStream",
                                    telemetry
                                }),
                                ...baseTelemetryAttributes,
                                "ai.prompt.messages": {
                                    input: ()=>stringifyForTelemetry(callOptions.prompt)
                                },
                                // standardized gen-ai llm span attributes:
                                "gen_ai.system": model.provider,
                                "gen_ai.request.model": model.modelId,
                                "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                                "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                                "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                                "gen_ai.request.temperature": callSettings.temperature,
                                "gen_ai.request.top_k": callSettings.topK,
                                "gen_ai.request.top_p": callSettings.topP
                            }
                        }),
                        tracer,
                        endWhenDone: false,
                        fn: async (doStreamSpan2)=>({
                                startTimestampMs: now2(),
                                doStreamSpan: doStreamSpan2,
                                result: await model.doStream(callOptions)
                            })
                    }));
                self._request.resolve(request != null ? request : {});
                let warnings;
                let usage = {
                    inputTokens: void 0,
                    outputTokens: void 0,
                    totalTokens: void 0
                };
                let finishReason;
                let providerMetadata;
                let object2;
                let error;
                let accumulatedText = "";
                let textDelta = "";
                let fullResponse = {
                    id: generateId3(),
                    timestamp: currentDate(),
                    modelId: model.modelId
                };
                let latestObjectJson = void 0;
                let latestObject = void 0;
                let isFirstChunk = true;
                let isFirstDelta = true;
                const transformedStream = stream.pipeThrough(new TransformStream(transformer)).pipeThrough(new TransformStream({
                    async transform (chunk, controller) {
                        var _a17, _b, _c;
                        if (typeof chunk === "object" && chunk.type === "stream-start") {
                            warnings = chunk.warnings;
                            return;
                        }
                        if (isFirstChunk) {
                            const msToFirstChunk = now2() - startTimestampMs;
                            isFirstChunk = false;
                            doStreamSpan.addEvent("ai.stream.firstChunk", {
                                "ai.stream.msToFirstChunk": msToFirstChunk
                            });
                            doStreamSpan.setAttributes({
                                "ai.stream.msToFirstChunk": msToFirstChunk
                            });
                        }
                        if (typeof chunk === "string") {
                            accumulatedText += chunk;
                            textDelta += chunk;
                            const { value: currentObjectJson, state: parseState } = await parsePartialJson(accumulatedText);
                            if (currentObjectJson !== void 0 && !isDeepEqualData(latestObjectJson, currentObjectJson)) {
                                const validationResult = await outputStrategy.validatePartialResult({
                                    value: currentObjectJson,
                                    textDelta,
                                    latestObject,
                                    isFirstDelta,
                                    isFinalDelta: parseState === "successful-parse"
                                });
                                if (validationResult.success && !isDeepEqualData(latestObject, validationResult.value.partial)) {
                                    latestObjectJson = currentObjectJson;
                                    latestObject = validationResult.value.partial;
                                    controller.enqueue({
                                        type: "object",
                                        object: latestObject
                                    });
                                    controller.enqueue({
                                        type: "text-delta",
                                        textDelta: validationResult.value.textDelta
                                    });
                                    textDelta = "";
                                    isFirstDelta = false;
                                }
                            }
                            return;
                        }
                        switch(chunk.type){
                            case "response-metadata":
                                {
                                    fullResponse = {
                                        id: (_a17 = chunk.id) != null ? _a17 : fullResponse.id,
                                        timestamp: (_b = chunk.timestamp) != null ? _b : fullResponse.timestamp,
                                        modelId: (_c = chunk.modelId) != null ? _c : fullResponse.modelId
                                    };
                                    break;
                                }
                            case "finish":
                                {
                                    if (textDelta !== "") {
                                        controller.enqueue({
                                            type: "text-delta",
                                            textDelta
                                        });
                                    }
                                    finishReason = chunk.finishReason;
                                    usage = chunk.usage;
                                    providerMetadata = chunk.providerMetadata;
                                    controller.enqueue({
                                        ...chunk,
                                        usage,
                                        response: fullResponse
                                    });
                                    self._usage.resolve(usage);
                                    self._providerMetadata.resolve(providerMetadata);
                                    self._response.resolve({
                                        ...fullResponse,
                                        headers: response == null ? void 0 : response.headers
                                    });
                                    const validationResult = await outputStrategy.validateFinalResult(latestObjectJson, {
                                        text: accumulatedText,
                                        response: fullResponse,
                                        usage
                                    });
                                    if (validationResult.success) {
                                        object2 = validationResult.value;
                                        self._object.resolve(object2);
                                    } else {
                                        error = new NoObjectGeneratedError({
                                            message: "No object generated: response did not match schema.",
                                            cause: validationResult.error,
                                            text: accumulatedText,
                                            response: fullResponse,
                                            usage,
                                            finishReason
                                        });
                                        self._object.reject(error);
                                    }
                                    break;
                                }
                            default:
                                {
                                    controller.enqueue(chunk);
                                    break;
                                }
                        }
                    },
                    // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
                    async flush (controller) {
                        try {
                            const finalUsage = usage != null ? usage : {
                                promptTokens: NaN,
                                completionTokens: NaN,
                                totalTokens: NaN
                            };
                            doStreamSpan.setAttributes(selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    "ai.response.finishReason": finishReason,
                                    "ai.response.object": {
                                        output: ()=>JSON.stringify(object2)
                                    },
                                    "ai.response.id": fullResponse.id,
                                    "ai.response.model": fullResponse.modelId,
                                    "ai.response.timestamp": fullResponse.timestamp.toISOString(),
                                    "ai.usage.inputTokens": finalUsage.inputTokens,
                                    "ai.usage.outputTokens": finalUsage.outputTokens,
                                    "ai.usage.totalTokens": finalUsage.totalTokens,
                                    "ai.usage.reasoningTokens": finalUsage.reasoningTokens,
                                    "ai.usage.cachedInputTokens": finalUsage.cachedInputTokens,
                                    // standardized gen-ai llm span attributes:
                                    "gen_ai.response.finish_reasons": [
                                        finishReason
                                    ],
                                    "gen_ai.response.id": fullResponse.id,
                                    "gen_ai.response.model": fullResponse.modelId,
                                    "gen_ai.usage.input_tokens": finalUsage.inputTokens,
                                    "gen_ai.usage.output_tokens": finalUsage.outputTokens
                                }
                            }));
                            doStreamSpan.end();
                            rootSpan.setAttributes(selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    "ai.usage.inputTokens": finalUsage.inputTokens,
                                    "ai.usage.outputTokens": finalUsage.outputTokens,
                                    "ai.usage.totalTokens": finalUsage.totalTokens,
                                    "ai.usage.reasoningTokens": finalUsage.reasoningTokens,
                                    "ai.usage.cachedInputTokens": finalUsage.cachedInputTokens,
                                    "ai.response.object": {
                                        output: ()=>JSON.stringify(object2)
                                    }
                                }
                            }));
                            await (onFinish == null ? void 0 : onFinish({
                                usage: finalUsage,
                                object: object2,
                                error,
                                response: {
                                    ...fullResponse,
                                    headers: response == null ? void 0 : response.headers
                                },
                                warnings,
                                providerMetadata
                            }));
                        } catch (error2) {
                            controller.enqueue({
                                type: "error",
                                error: error2
                            });
                        } finally{
                            rootSpan.end();
                        }
                    }
                }));
                stitchableStream.addStream(transformedStream);
            }
        }).catch((error)=>{
            stitchableStream.addStream(new ReadableStream({
                start (controller) {
                    controller.enqueue({
                        type: "error",
                        error
                    });
                    controller.close();
                }
            }));
        }).finally(()=>{
            stitchableStream.close();
        });
        this.outputStrategy = outputStrategy;
    }
    get object() {
        return this._object.promise;
    }
    get usage() {
        return this._usage.promise;
    }
    get providerMetadata() {
        return this._providerMetadata.promise;
    }
    get warnings() {
        return this._warnings.promise;
    }
    get request() {
        return this._request.promise;
    }
    get response() {
        return this._response.promise;
    }
    get partialObjectStream() {
        return createAsyncIterableStream(this.baseStream.pipeThrough(new TransformStream({
            transform (chunk, controller) {
                switch(chunk.type){
                    case "object":
                        controller.enqueue(chunk.object);
                        break;
                    case "text-delta":
                    case "finish":
                    case "error":
                        break;
                    default:
                        {
                            const _exhaustiveCheck = chunk;
                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
                        }
                }
            }
        })));
    }
    get elementStream() {
        return this.outputStrategy.createElementStream(this.baseStream);
    }
    get textStream() {
        return createAsyncIterableStream(this.baseStream.pipeThrough(new TransformStream({
            transform (chunk, controller) {
                switch(chunk.type){
                    case "text-delta":
                        controller.enqueue(chunk.textDelta);
                        break;
                    case "object":
                    case "finish":
                    case "error":
                        break;
                    default:
                        {
                            const _exhaustiveCheck = chunk;
                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);
                        }
                }
            }
        })));
    }
    get fullStream() {
        return createAsyncIterableStream(this.baseStream);
    }
    pipeTextStreamToResponse(response, init) {
        pipeTextStreamToResponse({
            response,
            textStream: this.textStream,
            ...init
        });
    }
    toTextStreamResponse(init) {
        return createTextStreamResponse({
            textStream: this.textStream,
            ...init
        });
    }
};
;
var NoSpeechGeneratedError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor(options){
        super({
            name: "AI_NoSpeechGeneratedError",
            message: "No speech audio generated."
        });
        this.responses = options.responses;
    }
};
// core/generate-speech/generated-audio-file.ts
var DefaultGeneratedAudioFile = class extends DefaultGeneratedFile {
    constructor({ data, mediaType }){
        super({
            data,
            mediaType
        });
        let format = "mp3";
        if (mediaType) {
            const mediaTypeParts = mediaType.split("/");
            if (mediaTypeParts.length === 2) {
                if (mediaType !== "audio/mpeg") {
                    format = mediaTypeParts[1];
                }
            }
        }
        if (!format) {
            throw new Error("Audio format must be provided or determinable from media type");
        }
        this.format = format;
    }
};
// core/generate-speech/generate-speech.ts
async function generateSpeech({ model, text: text2, voice, outputFormat, instructions, speed, providerOptions = {}, maxRetries: maxRetriesArg, abortSignal, headers }) {
    var _a17;
    const { retry } = prepareRetries({
        maxRetries: maxRetriesArg
    });
    const result = await retry(()=>model.doGenerate({
            text: text2,
            voice,
            outputFormat,
            instructions,
            speed,
            abortSignal,
            headers,
            providerOptions
        }));
    if (!result.audio || result.audio.length === 0) {
        throw new NoSpeechGeneratedError({
            responses: [
                result.response
            ]
        });
    }
    return new DefaultSpeechResult({
        audio: new DefaultGeneratedAudioFile({
            data: result.audio,
            mediaType: (_a17 = detectMediaType({
                data: result.audio,
                signatures: audioMediaTypeSignatures
            })) != null ? _a17 : "audio/mp3"
        }),
        warnings: result.warnings,
        responses: [
            result.response
        ],
        providerMetadata: result.providerMetadata
    });
}
var DefaultSpeechResult = class {
    constructor(options){
        var _a17;
        this.audio = options.audio;
        this.warnings = options.warnings;
        this.responses = options.responses;
        this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};
    }
};
;
// src/util/as-array.ts
function asArray(value) {
    return value === void 0 ? [] : Array.isArray(value) ? value : [
        value
    ];
}
;
// src/util/is-non-empty-object.ts
function isNonEmptyObject(object2) {
    return object2 != null && Object.keys(object2).length > 0;
}
// core/prompt/prepare-tools-and-tool-choice.ts
function prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {
    if (!isNonEmptyObject(tools)) {
        return {
            tools: void 0,
            toolChoice: void 0
        };
    }
    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name17])=>activeTools.includes(name17)) : Object.entries(tools);
    return {
        tools: filteredTools.map(([name17, tool2])=>{
            const toolType = tool2.type;
            switch(toolType){
                case void 0:
                case "function":
                    return {
                        type: "function",
                        name: name17,
                        description: tool2.description,
                        parameters: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["asSchema"])(tool2.parameters).jsonSchema
                    };
                case "provider-defined":
                    return {
                        type: "provider-defined",
                        name: name17,
                        id: tool2.id,
                        args: tool2.args
                    };
                default:
                    {
                        const exhaustiveCheck = toolType;
                        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);
                    }
            }
        }),
        toolChoice: toolChoice == null ? {
            type: "auto"
        } : typeof toolChoice === "string" ? {
            type: toolChoice
        } : {
            type: "tool",
            toolName: toolChoice.toolName
        }
    };
}
// core/types/usage.ts
function addLanguageModelUsage(usage1, usage2) {
    return {
        inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),
        outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),
        totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),
        reasoningTokens: addTokenCounts(usage1.reasoningTokens, usage2.reasoningTokens),
        cachedInputTokens: addTokenCounts(usage1.cachedInputTokens, usage2.cachedInputTokens)
    };
}
function addTokenCounts(tokenCount1, tokenCount2) {
    return tokenCount1 == null && tokenCount2 == null ? void 0 : (tokenCount1 != null ? tokenCount1 : 0) + (tokenCount2 != null ? tokenCount2 : 0);
}
// core/generate-text/as-content.ts
function asContent({ content, toolCalls, toolResults }) {
    return [
        ...content.map((part)=>{
            switch(part.type){
                case "text":
                case "reasoning":
                case "source":
                    return part;
                case "file":
                    {
                        return {
                            type: "file",
                            file: new DefaultGeneratedFile(part)
                        };
                    }
                case "tool-call":
                    {
                        return toolCalls.find((toolCall)=>toolCall.toolCallId === part.toolCallId);
                    }
            }
        }),
        ...toolResults
    ];
}
;
async function parseToolCall({ toolCall, tools, repairToolCall, system, messages }) {
    if (tools == null) {
        throw new NoSuchToolError({
            toolName: toolCall.toolName
        });
    }
    try {
        return await doParseToolCall({
            toolCall,
            tools
        });
    } catch (error) {
        if (repairToolCall == null || !(NoSuchToolError.isInstance(error) || InvalidToolArgumentsError.isInstance(error))) {
            throw error;
        }
        let repairedToolCall = null;
        try {
            repairedToolCall = await repairToolCall({
                toolCall,
                tools,
                parameterSchema: ({ toolName })=>{
                    const { parameters } = tools[toolName];
                    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["asSchema"])(parameters).jsonSchema;
                },
                system,
                messages,
                error
            });
        } catch (repairError) {
            throw new ToolCallRepairError({
                cause: repairError,
                originalError: error
            });
        }
        if (repairedToolCall == null) {
            throw error;
        }
        return await doParseToolCall({
            toolCall: repairedToolCall,
            tools
        });
    }
}
async function doParseToolCall({ toolCall, tools }) {
    const toolName = toolCall.toolName;
    const tool2 = tools[toolName];
    if (tool2 == null) {
        throw new NoSuchToolError({
            toolName: toolCall.toolName,
            availableTools: Object.keys(tools)
        });
    }
    const schema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["asSchema"])(tool2.parameters);
    const parseResult = toolCall.args.trim() === "" ? await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeValidateTypes"])({
        value: {},
        schema
    }) : await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeParseJSON"])({
        text: toolCall.args,
        schema
    });
    if (parseResult.success === false) {
        throw new InvalidToolArgumentsError({
            toolName,
            toolArgs: toolCall.args,
            cause: parseResult.error
        });
    }
    return {
        type: "tool-call",
        toolCallId: toolCall.toolCallId,
        toolName,
        args: parseResult == null ? void 0 : parseResult.value
    };
}
// core/generate-text/step-result.ts
var DefaultStepResult = class {
    constructor({ content, finishReason, usage, warnings, request, response, providerMetadata }){
        this.content = content;
        this.finishReason = finishReason;
        this.usage = usage;
        this.warnings = warnings;
        this.request = request;
        this.response = response;
        this.providerMetadata = providerMetadata;
    }
    get text() {
        return this.content.filter((part)=>part.type === "text").map((part)=>part.text).join("");
    }
    get reasoning() {
        return this.content.filter((part)=>part.type === "reasoning");
    }
    get reasoningText() {
        return this.reasoning.length === 0 ? void 0 : this.reasoning.map((part)=>part.text).join("");
    }
    get files() {
        return this.content.filter((part)=>part.type === "file").map((part)=>part.file);
    }
    get sources() {
        return this.content.filter((part)=>part.type === "source");
    }
    get toolCalls() {
        return this.content.filter((part)=>part.type === "tool-call");
    }
    get toolResults() {
        return this.content.filter((part)=>part.type === "tool-result");
    }
};
// core/generate-text/stop-condition.ts
function stepCountIs(stepCount) {
    return ({ steps })=>steps.length === stepCount;
}
function hasToolCall(toolName) {
    return ({ steps })=>{
        var _a17, _b, _c;
        return (_c = (_b = (_a17 = steps[steps.length - 1]) == null ? void 0 : _a17.toolCalls) == null ? void 0 : _b.some((toolCall)=>toolCall.toolName === toolName)) != null ? _c : false;
    };
}
async function isStopConditionMet({ stopConditions, steps }) {
    return (await Promise.all(stopConditions.map((condition)=>condition({
            steps
        })))).some((result)=>result);
}
// core/generate-text/to-response-messages.ts
function toResponseMessages({ content: inputContent, tools }) {
    const responseMessages = [];
    const content = inputContent.filter((part)=>part.type !== "tool-result" && part.type !== "source").filter((part)=>part.type !== "text" || part.text.length > 0).map((part)=>{
        switch(part.type){
            case "text":
                return part;
            case "reasoning":
                return {
                    type: "reasoning",
                    text: part.text,
                    providerOptions: part.providerMetadata
                };
            case "file":
                return {
                    type: "file",
                    data: part.file.base64,
                    mediaType: part.file.mediaType
                };
            case "tool-call":
                return part;
        }
    });
    if (content.length > 0) {
        responseMessages.push({
            role: "assistant",
            content
        });
    }
    const toolResultContent = inputContent.filter((part)=>part.type === "tool-result").map((toolResult)=>{
        const tool2 = tools[toolResult.toolName];
        return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {
            type: "tool-result",
            toolCallId: toolResult.toolCallId,
            toolName: toolResult.toolName,
            result: tool2.experimental_toToolResultContent(toolResult.result),
            experimental_content: tool2.experimental_toToolResultContent(toolResult.result)
        } : {
            type: "tool-result",
            toolCallId: toolResult.toolCallId,
            toolName: toolResult.toolName,
            result: toolResult.result
        };
    });
    if (toolResultContent.length > 0) {
        responseMessages.push({
            role: "tool",
            content: toolResultContent
        });
    }
    return responseMessages;
}
// core/generate-text/generate-text.ts
var originalGenerateId3 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createIdGenerator"])({
    prefix: "aitxt",
    size: 24
});
async function generateText({ model: modelArg, tools, toolChoice, system, prompt, messages, maxRetries: maxRetriesArg, abortSignal, headers, stopWhen = stepCountIs(1), experimental_output: output, experimental_telemetry: telemetry, providerOptions, experimental_activeTools, activeTools = experimental_activeTools, experimental_prepareStep, prepareStep = experimental_prepareStep, experimental_repairToolCall: repairToolCall, _internal: { generateId: generateId3 = originalGenerateId3, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, onStepFinish, ...settings }) {
    const model = resolveLanguageModel(modelArg);
    const stopConditions = asArray(stopWhen);
    const { maxRetries, retry } = prepareRetries({
        maxRetries: maxRetriesArg
    });
    const callSettings = prepareCallSettings(settings);
    const baseTelemetryAttributes = getBaseTelemetryAttributes({
        model,
        telemetry,
        headers,
        settings: {
            ...callSettings,
            maxRetries
        }
    });
    const initialPrompt = await standardizePrompt({
        system,
        prompt,
        messages
    });
    const tracer = getTracer(telemetry);
    try {
        return await recordSpan({
            name: "ai.generateText",
            attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                    ...assembleOperationName({
                        operationId: "ai.generateText",
                        telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // model:
                    "ai.model.provider": model.provider,
                    "ai.model.id": model.modelId,
                    // specific settings that only make sense on the outer level:
                    "ai.prompt": {
                        input: ()=>JSON.stringify({
                                system,
                                prompt,
                                messages
                            })
                    }
                }
            }),
            tracer,
            fn: async (span)=>{
                var _a17, _b, _c, _d, _e;
                const callSettings2 = prepareCallSettings(settings);
                let currentModelResponse;
                let currentToolCalls = [];
                let currentToolResults = [];
                const responseMessages = [];
                const steps = [];
                do {
                    const stepInputMessages = [
                        ...initialPrompt.messages,
                        ...responseMessages
                    ];
                    const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
                        model,
                        steps,
                        stepNumber: steps.length
                    }));
                    const promptMessages = await convertToLanguageModelPrompt({
                        prompt: {
                            system: (_a17 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _a17 : initialPrompt.system,
                            messages: stepInputMessages
                        },
                        supportedUrls: await model.supportedUrls
                    });
                    const stepModel = resolveLanguageModel((_b = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _b : model);
                    const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({
                        tools,
                        toolChoice: (_c = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _c : toolChoice,
                        activeTools: (_d = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _d : activeTools
                    });
                    currentModelResponse = await retry(()=>{
                        var _a18;
                        return recordSpan({
                            name: "ai.generateText.doGenerate",
                            attributes: selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    ...assembleOperationName({
                                        operationId: "ai.generateText.doGenerate",
                                        telemetry
                                    }),
                                    ...baseTelemetryAttributes,
                                    // model:
                                    "ai.model.provider": stepModel.provider,
                                    "ai.model.id": stepModel.modelId,
                                    // prompt:
                                    "ai.prompt.messages": {
                                        input: ()=>stringifyForTelemetry(promptMessages)
                                    },
                                    "ai.prompt.tools": {
                                        // convert the language model level tools:
                                        input: ()=>stepTools == null ? void 0 : stepTools.map((tool2)=>JSON.stringify(tool2))
                                    },
                                    "ai.prompt.toolChoice": {
                                        input: ()=>stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                                    },
                                    // standardized gen-ai llm span attributes:
                                    "gen_ai.system": stepModel.provider,
                                    "gen_ai.request.model": stepModel.modelId,
                                    "gen_ai.request.frequency_penalty": settings.frequencyPenalty,
                                    "gen_ai.request.max_tokens": settings.maxOutputTokens,
                                    "gen_ai.request.presence_penalty": settings.presencePenalty,
                                    "gen_ai.request.stop_sequences": settings.stopSequences,
                                    "gen_ai.request.temperature": (_a18 = settings.temperature) != null ? _a18 : void 0,
                                    "gen_ai.request.top_k": settings.topK,
                                    "gen_ai.request.top_p": settings.topP
                                }
                            }),
                            tracer,
                            fn: async (span2)=>{
                                var _a19, _b2, _c2, _d2, _e2, _f, _g, _h;
                                const result = await stepModel.doGenerate({
                                    ...callSettings2,
                                    tools: stepTools,
                                    toolChoice: stepToolChoice,
                                    responseFormat: output == null ? void 0 : output.responseFormat,
                                    prompt: promptMessages,
                                    providerOptions,
                                    abortSignal,
                                    headers
                                });
                                const responseData = {
                                    id: (_b2 = (_a19 = result.response) == null ? void 0 : _a19.id) != null ? _b2 : generateId3(),
                                    timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),
                                    modelId: (_f = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f : stepModel.modelId,
                                    headers: (_g = result.response) == null ? void 0 : _g.headers,
                                    body: (_h = result.response) == null ? void 0 : _h.body
                                };
                                span2.setAttributes(selectTelemetryAttributes({
                                    telemetry,
                                    attributes: {
                                        "ai.response.finishReason": result.finishReason,
                                        "ai.response.text": {
                                            output: ()=>extractContentText(result.content)
                                        },
                                        "ai.response.toolCalls": {
                                            output: ()=>{
                                                const toolCalls = asToolCalls(result.content);
                                                return toolCalls == null ? void 0 : JSON.stringify(toolCalls);
                                            }
                                        },
                                        "ai.response.id": responseData.id,
                                        "ai.response.model": responseData.modelId,
                                        "ai.response.timestamp": responseData.timestamp.toISOString(),
                                        // TODO rename telemetry attributes to inputTokens and outputTokens
                                        "ai.usage.promptTokens": result.usage.inputTokens,
                                        "ai.usage.completionTokens": result.usage.outputTokens,
                                        // standardized gen-ai llm span attributes:
                                        "gen_ai.response.finish_reasons": [
                                            result.finishReason
                                        ],
                                        "gen_ai.response.id": responseData.id,
                                        "gen_ai.response.model": responseData.modelId,
                                        "gen_ai.usage.input_tokens": result.usage.inputTokens,
                                        "gen_ai.usage.output_tokens": result.usage.outputTokens
                                    }
                                }));
                                return {
                                    ...result,
                                    response: responseData
                                };
                            }
                        });
                    });
                    currentToolCalls = await Promise.all(currentModelResponse.content.filter((part)=>part.type === "tool-call").map((toolCall)=>parseToolCall({
                            toolCall,
                            tools,
                            repairToolCall,
                            system,
                            messages: stepInputMessages
                        })));
                    currentToolResults = tools == null ? [] : await executeTools({
                        toolCalls: currentToolCalls,
                        tools,
                        tracer,
                        telemetry,
                        messages: stepInputMessages,
                        abortSignal
                    });
                    const stepContent = asContent({
                        content: currentModelResponse.content,
                        toolCalls: currentToolCalls,
                        toolResults: currentToolResults
                    });
                    responseMessages.push(...toResponseMessages({
                        content: stepContent,
                        tools: tools != null ? tools : {}
                    }));
                    const currentStepResult = new DefaultStepResult({
                        content: stepContent,
                        finishReason: currentModelResponse.finishReason,
                        usage: currentModelResponse.usage,
                        warnings: currentModelResponse.warnings,
                        providerMetadata: currentModelResponse.providerMetadata,
                        request: (_e = currentModelResponse.request) != null ? _e : {},
                        response: {
                            ...currentModelResponse.response,
                            // deep clone msgs to avoid mutating past messages in multi-step:
                            messages: structuredClone(responseMessages)
                        }
                    });
                    steps.push(currentStepResult);
                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
                }while (// there are tool calls:
                currentToolCalls.length > 0 && // all current tool calls have results:
                currentToolResults.length === currentToolCalls.length && // continue until a stop condition is met:
                !await isStopConditionMet({
                    stopConditions,
                    steps
                }))
                span.setAttributes(selectTelemetryAttributes({
                    telemetry,
                    attributes: {
                        "ai.response.finishReason": currentModelResponse.finishReason,
                        "ai.response.text": {
                            output: ()=>extractContentText(currentModelResponse.content)
                        },
                        "ai.response.toolCalls": {
                            output: ()=>{
                                const toolCalls = asToolCalls(currentModelResponse.content);
                                return toolCalls == null ? void 0 : JSON.stringify(toolCalls);
                            }
                        },
                        // TODO rename telemetry attributes to inputTokens and outputTokens
                        "ai.usage.promptTokens": currentModelResponse.usage.inputTokens,
                        "ai.usage.completionTokens": currentModelResponse.usage.outputTokens
                    }
                }));
                const lastStep = steps[steps.length - 1];
                return new DefaultGenerateTextResult({
                    steps,
                    resolvedOutput: await (output == null ? void 0 : output.parseOutput({
                        text: lastStep.text
                    }, {
                        response: lastStep.response,
                        usage: lastStep.usage,
                        finishReason: lastStep.finishReason
                    }))
                });
            }
        });
    } catch (error) {
        throw wrapGatewayError(error);
    }
}
async function executeTools({ toolCalls, tools, tracer, telemetry, messages, abortSignal }) {
    const toolResults = await Promise.all(toolCalls.map(async ({ toolCallId, toolName, args })=>{
        const tool2 = tools[toolName];
        if ((tool2 == null ? void 0 : tool2.onArgsAvailable) != null) {
            await tool2.onArgsAvailable({
                args,
                toolCallId,
                messages,
                abortSignal
            });
        }
        if ((tool2 == null ? void 0 : tool2.execute) == null) {
            return void 0;
        }
        const result = await recordSpan({
            name: "ai.toolCall",
            attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                    ...assembleOperationName({
                        operationId: "ai.toolCall",
                        telemetry
                    }),
                    "ai.toolCall.name": toolName,
                    "ai.toolCall.id": toolCallId,
                    "ai.toolCall.args": {
                        output: ()=>JSON.stringify(args)
                    }
                }
            }),
            tracer,
            fn: async (span)=>{
                try {
                    const result2 = await tool2.execute(args, {
                        toolCallId,
                        messages,
                        abortSignal
                    });
                    try {
                        span.setAttributes(selectTelemetryAttributes({
                            telemetry,
                            attributes: {
                                "ai.toolCall.result": {
                                    output: ()=>JSON.stringify(result2)
                                }
                            }
                        }));
                    } catch (ignored) {}
                    return result2;
                } catch (error) {
                    throw new ToolExecutionError({
                        toolCallId,
                        toolName,
                        toolArgs: args,
                        cause: error
                    });
                }
            }
        });
        return {
            type: "tool-result",
            toolCallId,
            toolName,
            args,
            result
        };
    }));
    return toolResults.filter((result)=>result != null);
}
var DefaultGenerateTextResult = class {
    constructor(options){
        this.steps = options.steps;
        this.resolvedOutput = options.resolvedOutput;
    }
    get finalStep() {
        return this.steps[this.steps.length - 1];
    }
    get content() {
        return this.finalStep.content;
    }
    get text() {
        return this.finalStep.text;
    }
    get files() {
        return this.finalStep.files;
    }
    get reasoningText() {
        return this.finalStep.reasoningText;
    }
    get reasoning() {
        return this.finalStep.reasoning;
    }
    get toolCalls() {
        return this.finalStep.toolCalls;
    }
    get toolResults() {
        return this.finalStep.toolResults;
    }
    get sources() {
        return this.finalStep.sources;
    }
    get finishReason() {
        return this.finalStep.finishReason;
    }
    get warnings() {
        return this.finalStep.warnings;
    }
    get providerMetadata() {
        return this.finalStep.providerMetadata;
    }
    get response() {
        return this.finalStep.response;
    }
    get request() {
        return this.finalStep.request;
    }
    get usage() {
        return this.finalStep.usage;
    }
    get totalUsage() {
        return this.steps.reduce((totalUsage, step)=>{
            return addLanguageModelUsage(totalUsage, step.usage);
        }, {
            inputTokens: void 0,
            outputTokens: void 0,
            totalTokens: void 0,
            reasoningTokens: void 0,
            cachedInputTokens: void 0
        });
    }
    get experimental_output() {
        if (this.resolvedOutput == null) {
            throw new NoOutputSpecifiedError();
        }
        return this.resolvedOutput;
    }
};
function asToolCalls(content) {
    const parts = content.filter((part)=>part.type === "tool-call");
    if (parts.length === 0) {
        return void 0;
    }
    return parts.map((toolCall)=>({
            toolCallType: toolCall.toolCallType,
            toolCallId: toolCall.toolCallId,
            toolName: toolCall.toolName,
            args: toolCall.args
        }));
}
// core/generate-text/output.ts
var output_exports = {};
__export(output_exports, {
    object: ()=>object,
    text: ()=>text
});
;
var text = ()=>({
        type: "text",
        responseFormat: {
            type: "text"
        },
        async parsePartial ({ text: text2 }) {
            return {
                partial: text2
            };
        },
        async parseOutput ({ text: text2 }) {
            return text2;
        }
    });
var object = ({ schema: inputSchema })=>{
    const schema = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["asSchema"])(inputSchema);
    return {
        type: "object",
        responseFormat: {
            type: "json",
            schema: schema.jsonSchema
        },
        async parsePartial ({ text: text2 }) {
            const result = await parsePartialJson(text2);
            switch(result.state){
                case "failed-parse":
                case "undefined-input":
                    return void 0;
                case "repaired-parse":
                case "successful-parse":
                    return {
                        // Note: currently no validation of partial results:
                        partial: result.value
                    };
                default:
                    {
                        const _exhaustiveCheck = result.state;
                        throw new Error(`Unsupported parse state: ${_exhaustiveCheck}`);
                    }
            }
        },
        async parseOutput ({ text: text2 }, context) {
            const parseResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeParseJSON"])({
                text: text2
            });
            if (!parseResult.success) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: could not parse the response.",
                    cause: parseResult.error,
                    text: text2,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            const validationResult = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["safeValidateTypes"])({
                value: parseResult.value,
                schema
            });
            if (!validationResult.success) {
                throw new NoObjectGeneratedError({
                    message: "No object generated: response did not match schema.",
                    cause: validationResult.error,
                    text: text2,
                    response: context.response,
                    usage: context.usage,
                    finishReason: context.finishReason
                });
            }
            return validationResult.value;
        }
    };
};
;
;
var CHUNKING_REGEXPS = {
    word: /\S+\s+/m,
    line: /\n+/m
};
function smoothStream({ delayInMs = 10, chunking = "word", _internal: { delay: delay2 = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["delay"] } = {} } = {}) {
    let detectChunk;
    if (typeof chunking === "function") {
        detectChunk = (buffer)=>{
            const match = chunking(buffer);
            if (match == null) {
                return null;
            }
            if (!match.length) {
                throw new Error(`Chunking function must return a non-empty string.`);
            }
            if (!buffer.startsWith(match)) {
                throw new Error(`Chunking function must return a match that is a prefix of the buffer. Received: "${match}" expected to start with "${buffer}"`);
            }
            return match;
        };
    } else {
        const chunkingRegex = typeof chunking === "string" ? CHUNKING_REGEXPS[chunking] : chunking;
        if (chunkingRegex == null) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InvalidArgumentError"]({
                argument: "chunking",
                message: `Chunking must be "word" or "line" or a RegExp. Received: ${chunking}`
            });
        }
        detectChunk = (buffer)=>{
            const match = chunkingRegex.exec(buffer);
            if (!match) {
                return null;
            }
            return buffer.slice(0, match.index) + (match == null ? void 0 : match[0]);
        };
    }
    return ()=>{
        let buffer = "";
        return new TransformStream({
            async transform (chunk, controller) {
                if (chunk.type !== "text") {
                    if (buffer.length > 0) {
                        controller.enqueue({
                            type: "text",
                            text: buffer
                        });
                        buffer = "";
                    }
                    controller.enqueue(chunk);
                    return;
                }
                buffer += chunk.text;
                let match;
                while((match = detectChunk(buffer)) != null){
                    controller.enqueue({
                        type: "text",
                        text: match
                    });
                    buffer = buffer.slice(match.length);
                    await delay2(delayInMs);
                }
            }
        });
    };
}
;
;
function runToolsTransformation({ tools, generatorStream, tracer, telemetry, system, messages, abortSignal, repairToolCall }) {
    let toolResultsStreamController = null;
    const toolResultsStream = new ReadableStream({
        start (controller) {
            toolResultsStreamController = controller;
        }
    });
    const activeToolCalls = {};
    const outstandingToolResults = /* @__PURE__ */ new Set();
    let canClose = false;
    let finishChunk = void 0;
    function attemptClose() {
        if (canClose && outstandingToolResults.size === 0) {
            if (finishChunk != null) {
                toolResultsStreamController.enqueue(finishChunk);
            }
            toolResultsStreamController.close();
        }
    }
    const forwardStream = new TransformStream({
        async transform (chunk, controller) {
            const chunkType = chunk.type;
            switch(chunkType){
                case "stream-start":
                case "finish":
                case "text":
                case "reasoning":
                case "reasoning-part-finish":
                case "source":
                case "response-metadata":
                case "error":
                    {
                        controller.enqueue(chunk);
                        break;
                    }
                case "raw":
                    {
                        controller.enqueue(chunk);
                        break;
                    }
                case "file":
                    {
                        controller.enqueue({
                            type: "file",
                            file: new DefaultGeneratedFileWithType({
                                data: chunk.data,
                                mediaType: chunk.mediaType
                            })
                        });
                        break;
                    }
                case "tool-call-delta":
                    {
                        if (!activeToolCalls[chunk.toolCallId]) {
                            controller.enqueue({
                                type: "tool-call-streaming-start",
                                toolCallId: chunk.toolCallId,
                                toolName: chunk.toolName
                            });
                            activeToolCalls[chunk.toolCallId] = true;
                        }
                        controller.enqueue({
                            type: "tool-call-delta",
                            toolCallId: chunk.toolCallId,
                            toolName: chunk.toolName,
                            argsTextDelta: chunk.argsTextDelta
                        });
                        break;
                    }
                case "tool-call":
                    {
                        try {
                            const toolCall = await parseToolCall({
                                toolCall: chunk,
                                tools,
                                repairToolCall,
                                system,
                                messages
                            });
                            controller.enqueue(toolCall);
                            const tool2 = tools[toolCall.toolName];
                            if (tool2.onArgsAvailable != null) {
                                await tool2.onArgsAvailable({
                                    args: toolCall.args,
                                    toolCallId: toolCall.toolCallId,
                                    messages,
                                    abortSignal
                                });
                            }
                            if (tool2.execute != null) {
                                const toolExecutionId = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["generateId"])();
                                outstandingToolResults.add(toolExecutionId);
                                recordSpan({
                                    name: "ai.toolCall",
                                    attributes: selectTelemetryAttributes({
                                        telemetry,
                                        attributes: {
                                            ...assembleOperationName({
                                                operationId: "ai.toolCall",
                                                telemetry
                                            }),
                                            "ai.toolCall.name": toolCall.toolName,
                                            "ai.toolCall.id": toolCall.toolCallId,
                                            "ai.toolCall.args": {
                                                output: ()=>JSON.stringify(toolCall.args)
                                            }
                                        }
                                    }),
                                    tracer,
                                    fn: async (span)=>tool2.execute(toolCall.args, {
                                            toolCallId: toolCall.toolCallId,
                                            messages,
                                            abortSignal
                                        }).then((result)=>{
                                            toolResultsStreamController.enqueue({
                                                ...toolCall,
                                                type: "tool-result",
                                                result
                                            });
                                            outstandingToolResults.delete(toolExecutionId);
                                            attemptClose();
                                            try {
                                                span.setAttributes(selectTelemetryAttributes({
                                                    telemetry,
                                                    attributes: {
                                                        "ai.toolCall.result": {
                                                            output: ()=>JSON.stringify(result)
                                                        }
                                                    }
                                                }));
                                            } catch (ignored) {}
                                        }, (error)=>{
                                            toolResultsStreamController.enqueue({
                                                type: "error",
                                                error: new ToolExecutionError({
                                                    toolCallId: toolCall.toolCallId,
                                                    toolName: toolCall.toolName,
                                                    toolArgs: toolCall.args,
                                                    cause: error
                                                })
                                            });
                                            outstandingToolResults.delete(toolExecutionId);
                                            attemptClose();
                                        })
                                });
                            }
                        } catch (error) {
                            toolResultsStreamController.enqueue({
                                type: "error",
                                error
                            });
                        }
                        break;
                    }
                default:
                    {
                        const _exhaustiveCheck = chunkType;
                        throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);
                    }
            }
        },
        flush () {
            canClose = true;
            attemptClose();
        }
    });
    return new ReadableStream({
        async start (controller) {
            return Promise.all([
                generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({
                    write (chunk) {
                        controller.enqueue(chunk);
                    },
                    close () {}
                })),
                toolResultsStream.pipeTo(new WritableStream({
                    write (chunk) {
                        controller.enqueue(chunk);
                    },
                    close () {
                        controller.close();
                    }
                }))
            ]);
        }
    });
}
// core/generate-text/stream-text.ts
var originalGenerateId4 = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createIdGenerator"])({
    prefix: "aitxt",
    size: 24
});
function streamText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, stopWhen = stepCountIs(1), experimental_output: output, experimental_telemetry: telemetry, prepareStep, providerOptions, experimental_activeTools, activeTools = experimental_activeTools, experimental_repairToolCall: repairToolCall, experimental_transform: transform, includeRawChunks = false, onChunk, onError = ({ error })=>{
    console.error(error);
}, onFinish, onStepFinish, _internal: { now: now2 = now, generateId: generateId3 = originalGenerateId4, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {
    return new DefaultStreamTextResult({
        model: resolveLanguageModel(model),
        telemetry,
        headers,
        settings,
        maxRetries,
        abortSignal,
        system,
        prompt,
        messages,
        tools,
        toolChoice,
        transforms: asArray(transform),
        activeTools,
        repairToolCall,
        stopConditions: asArray(stopWhen),
        output,
        providerOptions,
        prepareStep,
        includeRawChunks,
        onChunk,
        onError,
        onFinish,
        onStepFinish,
        now: now2,
        currentDate,
        generateId: generateId3
    });
}
function createOutputTransformStream(output) {
    if (!output) {
        return new TransformStream({
            transform (chunk, controller) {
                controller.enqueue({
                    part: chunk,
                    partialOutput: void 0
                });
            }
        });
    }
    let text2 = "";
    let textChunk = "";
    let lastPublishedJson = "";
    function publishTextChunk({ controller, partialOutput = void 0 }) {
        controller.enqueue({
            part: {
                type: "text",
                text: textChunk
            },
            partialOutput
        });
        textChunk = "";
    }
    return new TransformStream({
        async transform (chunk, controller) {
            if (chunk.type === "finish-step") {
                publishTextChunk({
                    controller
                });
            }
            if (chunk.type !== "text") {
                controller.enqueue({
                    part: chunk,
                    partialOutput: void 0
                });
                return;
            }
            text2 += chunk.text;
            textChunk += chunk.text;
            const result = await output.parsePartial({
                text: text2
            });
            if (result != null) {
                const currentJson = JSON.stringify(result.partial);
                if (currentJson !== lastPublishedJson) {
                    publishTextChunk({
                        controller,
                        partialOutput: result.partial
                    });
                    lastPublishedJson = currentJson;
                }
            }
        },
        flush (controller) {
            if (textChunk.length > 0) {
                publishTextChunk({
                    controller
                });
            }
        }
    });
}
var DefaultStreamTextResult = class {
    constructor({ model, telemetry, headers, settings, maxRetries: maxRetriesArg, abortSignal, system, prompt, messages, tools, toolChoice, transforms, activeTools, repairToolCall, stopConditions, output, providerOptions, prepareStep, includeRawChunks, now: now2, currentDate, generateId: generateId3, onChunk, onError, onFinish, onStepFinish }){
        this._totalUsage = new DelayedPromise();
        this._finishReason = new DelayedPromise();
        this._steps = new DelayedPromise();
        this.output = output;
        this.includeRawChunks = includeRawChunks;
        this.generateId = generateId3;
        let stepFinish;
        let activeReasoningPart = void 0;
        let recordedContent = [];
        const recordedResponseMessages = [];
        let recordedFinishReason = void 0;
        let recordedTotalUsage = void 0;
        let recordedRequest = {};
        let recordedWarnings = [];
        const recordedSteps = [];
        let rootSpan;
        const eventProcessor = new TransformStream({
            async transform (chunk, controller) {
                controller.enqueue(chunk);
                const { part } = chunk;
                if (part.type === "text" || part.type === "reasoning" || part.type === "source" || part.type === "tool-call" || part.type === "tool-result" || part.type === "tool-call-streaming-start" || part.type === "tool-call-delta") {
                    await (onChunk == null ? void 0 : onChunk({
                        chunk: part
                    }));
                }
                if (part.type === "error") {
                    await onError({
                        error: wrapGatewayError(part.error)
                    });
                }
                if (part.type === "text") {
                    const latestContent = recordedContent[recordedContent.length - 1];
                    if ((latestContent == null ? void 0 : latestContent.type) === "text") {
                        latestContent.text += part.text;
                    } else {
                        recordedContent.push({
                            type: "text",
                            text: part.text
                        });
                    }
                }
                if (part.type === "reasoning") {
                    if (activeReasoningPart == null) {
                        activeReasoningPart = {
                            type: "reasoning",
                            text: part.text,
                            providerMetadata: part.providerMetadata
                        };
                        recordedContent.push(activeReasoningPart);
                    } else {
                        activeReasoningPart.text += part.text;
                        activeReasoningPart.providerMetadata = part.providerMetadata;
                    }
                }
                if (part.type === "reasoning-part-finish" && activeReasoningPart != null) {
                    activeReasoningPart = void 0;
                }
                if (part.type === "file") {
                    recordedContent.push({
                        type: "file",
                        file: part.file
                    });
                }
                if (part.type === "source") {
                    recordedContent.push(part);
                }
                if (part.type === "tool-call") {
                    recordedContent.push(part);
                }
                if (part.type === "tool-result") {
                    recordedContent.push(part);
                }
                if (part.type === "start-step") {
                    recordedRequest = part.request;
                    recordedWarnings = part.warnings;
                }
                if (part.type === "finish-step") {
                    const stepMessages = toResponseMessages({
                        content: recordedContent,
                        tools: tools != null ? tools : {}
                    });
                    const currentStepResult = new DefaultStepResult({
                        content: recordedContent,
                        finishReason: part.finishReason,
                        usage: part.usage,
                        warnings: recordedWarnings,
                        request: recordedRequest,
                        response: {
                            ...part.response,
                            messages: [
                                ...recordedResponseMessages,
                                ...stepMessages
                            ]
                        },
                        providerMetadata: part.providerMetadata
                    });
                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));
                    recordedSteps.push(currentStepResult);
                    recordedContent = [];
                    activeReasoningPart = void 0;
                    recordedResponseMessages.push(...stepMessages);
                    stepFinish.resolve();
                }
                if (part.type === "finish") {
                    recordedTotalUsage = part.totalUsage;
                    recordedFinishReason = part.finishReason;
                }
            },
            async flush (controller) {
                try {
                    if (recordedSteps.length === 0) {
                        return;
                    }
                    const finishReason = recordedFinishReason != null ? recordedFinishReason : "unknown";
                    const totalUsage = recordedTotalUsage != null ? recordedTotalUsage : {
                        inputTokens: void 0,
                        outputTokens: void 0,
                        totalTokens: void 0
                    };
                    self._finishReason.resolve(finishReason);
                    self._totalUsage.resolve(totalUsage);
                    self._steps.resolve(recordedSteps);
                    const finalStep = recordedSteps[recordedSteps.length - 1];
                    await (onFinish == null ? void 0 : onFinish({
                        finishReason,
                        totalUsage,
                        usage: finalStep.usage,
                        content: finalStep.content,
                        text: finalStep.text,
                        reasoningText: finalStep.reasoningText,
                        reasoning: finalStep.reasoning,
                        files: finalStep.files,
                        sources: finalStep.sources,
                        toolCalls: finalStep.toolCalls,
                        toolResults: finalStep.toolResults,
                        request: finalStep.request,
                        response: finalStep.response,
                        warnings: finalStep.warnings,
                        providerMetadata: finalStep.providerMetadata,
                        steps: recordedSteps
                    }));
                    rootSpan.setAttributes(selectTelemetryAttributes({
                        telemetry,
                        attributes: {
                            "ai.response.finishReason": finishReason,
                            "ai.response.text": {
                                output: ()=>finalStep.text
                            },
                            "ai.response.toolCalls": {
                                output: ()=>{
                                    var _a17;
                                    return ((_a17 = finalStep.toolCalls) == null ? void 0 : _a17.length) ? JSON.stringify(finalStep.toolCalls) : void 0;
                                }
                            },
                            "ai.usage.inputTokens": totalUsage.inputTokens,
                            "ai.usage.outputTokens": totalUsage.outputTokens,
                            "ai.usage.totalTokens": totalUsage.totalTokens,
                            "ai.usage.reasoningTokens": totalUsage.reasoningTokens,
                            "ai.usage.cachedInputTokens": totalUsage.cachedInputTokens
                        }
                    }));
                } catch (error) {
                    controller.error(error);
                } finally{
                    rootSpan.end();
                }
            }
        });
        const stitchableStream = createStitchableStream();
        this.addStream = stitchableStream.addStream;
        this.closeStream = stitchableStream.close;
        let stream = stitchableStream.stream;
        stream = stream.pipeThrough(new TransformStream({
            start (controller) {
                controller.enqueue({
                    type: "start"
                });
            }
        }));
        for (const transform of transforms){
            stream = stream.pipeThrough(transform({
                tools,
                stopStream () {
                    stitchableStream.terminate();
                }
            }));
        }
        this.baseStream = stream.pipeThrough(createOutputTransformStream(output)).pipeThrough(eventProcessor);
        const { maxRetries, retry } = prepareRetries({
            maxRetries: maxRetriesArg
        });
        const tracer = getTracer(telemetry);
        const callSettings = prepareCallSettings(settings);
        const baseTelemetryAttributes = getBaseTelemetryAttributes({
            model,
            telemetry,
            headers,
            settings: {
                ...callSettings,
                maxRetries
            }
        });
        const self = this;
        recordSpan({
            name: "ai.streamText",
            attributes: selectTelemetryAttributes({
                telemetry,
                attributes: {
                    ...assembleOperationName({
                        operationId: "ai.streamText",
                        telemetry
                    }),
                    ...baseTelemetryAttributes,
                    // specific settings that only make sense on the outer level:
                    "ai.prompt": {
                        input: ()=>JSON.stringify({
                                system,
                                prompt,
                                messages
                            })
                    }
                }
            }),
            tracer,
            endWhenDone: false,
            fn: async (rootSpanArg)=>{
                rootSpan = rootSpanArg;
                async function streamStep({ currentStep, responseMessages, usage }) {
                    var _a17, _b, _c, _d;
                    const includeRawChunks2 = self.includeRawChunks;
                    stepFinish = new DelayedPromise();
                    const initialPrompt = await standardizePrompt({
                        system,
                        prompt,
                        messages
                    });
                    const stepInputMessages = [
                        ...initialPrompt.messages,
                        ...responseMessages
                    ];
                    const prepareStepResult = await (prepareStep == null ? void 0 : prepareStep({
                        model,
                        steps: recordedSteps,
                        stepNumber: recordedSteps.length
                    }));
                    const promptMessages = await convertToLanguageModelPrompt({
                        prompt: {
                            system: (_a17 = prepareStepResult == null ? void 0 : prepareStepResult.system) != null ? _a17 : initialPrompt.system,
                            messages: stepInputMessages
                        },
                        supportedUrls: await model.supportedUrls
                    });
                    const stepModel = resolveLanguageModel((_b = prepareStepResult == null ? void 0 : prepareStepResult.model) != null ? _b : model);
                    const { toolChoice: stepToolChoice, tools: stepTools } = prepareToolsAndToolChoice({
                        tools,
                        toolChoice: (_c = prepareStepResult == null ? void 0 : prepareStepResult.toolChoice) != null ? _c : toolChoice,
                        activeTools: (_d = prepareStepResult == null ? void 0 : prepareStepResult.activeTools) != null ? _d : activeTools
                    });
                    const { result: { stream: stream2, response, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({
                            name: "ai.streamText.doStream",
                            attributes: selectTelemetryAttributes({
                                telemetry,
                                attributes: {
                                    ...assembleOperationName({
                                        operationId: "ai.streamText.doStream",
                                        telemetry
                                    }),
                                    ...baseTelemetryAttributes,
                                    // model:
                                    "ai.model.provider": stepModel.provider,
                                    "ai.model.id": stepModel.modelId,
                                    // prompt:
                                    "ai.prompt.messages": {
                                        input: ()=>stringifyForTelemetry(promptMessages)
                                    },
                                    "ai.prompt.tools": {
                                        // convert the language model level tools:
                                        input: ()=>stepTools == null ? void 0 : stepTools.map((tool2)=>JSON.stringify(tool2))
                                    },
                                    "ai.prompt.toolChoice": {
                                        input: ()=>stepToolChoice != null ? JSON.stringify(stepToolChoice) : void 0
                                    },
                                    // standardized gen-ai llm span attributes:
                                    "gen_ai.system": stepModel.provider,
                                    "gen_ai.request.model": stepModel.modelId,
                                    "gen_ai.request.frequency_penalty": callSettings.frequencyPenalty,
                                    "gen_ai.request.max_tokens": callSettings.maxOutputTokens,
                                    "gen_ai.request.presence_penalty": callSettings.presencePenalty,
                                    "gen_ai.request.stop_sequences": callSettings.stopSequences,
                                    "gen_ai.request.temperature": callSettings.temperature,
                                    "gen_ai.request.top_k": callSettings.topK,
                                    "gen_ai.request.top_p": callSettings.topP
                                }
                            }),
                            tracer,
                            endWhenDone: false,
                            fn: async (doStreamSpan2)=>{
                                return {
                                    startTimestampMs: now2(),
                                    // get before the call
                                    doStreamSpan: doStreamSpan2,
                                    result: await stepModel.doStream({
                                        ...callSettings,
                                        tools: stepTools,
                                        toolChoice: stepToolChoice,
                                        responseFormat: output == null ? void 0 : output.responseFormat,
                                        prompt: promptMessages,
                                        providerOptions,
                                        abortSignal,
                                        headers,
                                        includeRawChunks: includeRawChunks2
                                    })
                                };
                            }
                        }));
                    const streamWithToolResults = runToolsTransformation({
                        tools,
                        generatorStream: stream2,
                        tracer,
                        telemetry,
                        system,
                        messages: stepInputMessages,
                        repairToolCall,
                        abortSignal
                    });
                    const stepRequest = request != null ? request : {};
                    const stepToolCalls = [];
                    const stepToolResults = [];
                    let warnings;
                    const stepContent = [];
                    let activeReasoningPart2 = void 0;
                    let stepFinishReason = "unknown";
                    let stepUsage = {
                        inputTokens: void 0,
                        outputTokens: void 0,
                        totalTokens: void 0
                    };
                    let stepProviderMetadata;
                    let stepFirstChunk = true;
                    let stepText = "";
                    let stepResponse = {
                        id: generateId3(),
                        timestamp: currentDate(),
                        modelId: model.modelId
                    };
                    async function publishTextChunk({ controller, chunk }) {
                        controller.enqueue(chunk);
                        stepText += chunk.text;
                    }
                    self.addStream(streamWithToolResults.pipeThrough(new TransformStream({
                        async transform (chunk, controller) {
                            var _a18, _b2, _c2, _d2;
                            if (chunk.type === "stream-start") {
                                warnings = chunk.warnings;
                                return;
                            }
                            if (stepFirstChunk) {
                                const msToFirstChunk = now2() - startTimestampMs;
                                stepFirstChunk = false;
                                doStreamSpan.addEvent("ai.stream.firstChunk", {
                                    "ai.response.msToFirstChunk": msToFirstChunk
                                });
                                doStreamSpan.setAttributes({
                                    "ai.response.msToFirstChunk": msToFirstChunk
                                });
                                controller.enqueue({
                                    type: "start-step",
                                    request: stepRequest,
                                    warnings: warnings != null ? warnings : []
                                });
                            }
                            if (chunk.type === "text" && chunk.text.length === 0) {
                                return;
                            }
                            const chunkType = chunk.type;
                            switch(chunkType){
                                case "text":
                                    {
                                        await publishTextChunk({
                                            controller,
                                            chunk
                                        });
                                        break;
                                    }
                                case "reasoning":
                                    {
                                        controller.enqueue(chunk);
                                        if (activeReasoningPart2 == null) {
                                            activeReasoningPart2 = {
                                                type: "reasoning",
                                                text: chunk.text,
                                                providerMetadata: chunk.providerMetadata
                                            };
                                            stepContent.push(activeReasoningPart2);
                                        } else {
                                            activeReasoningPart2.text += chunk.text;
                                            activeReasoningPart2.providerMetadata = chunk.providerMetadata;
                                        }
                                        break;
                                    }
                                case "reasoning-part-finish":
                                    {
                                        activeReasoningPart2 = void 0;
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "tool-call":
                                    {
                                        controller.enqueue(chunk);
                                        stepToolCalls.push(chunk);
                                        stepContent.push(chunk);
                                        break;
                                    }
                                case "tool-result":
                                    {
                                        controller.enqueue(chunk);
                                        stepToolResults.push(chunk);
                                        stepContent.push(chunk);
                                        break;
                                    }
                                case "response-metadata":
                                    {
                                        stepResponse = {
                                            id: (_a18 = chunk.id) != null ? _a18 : stepResponse.id,
                                            timestamp: (_b2 = chunk.timestamp) != null ? _b2 : stepResponse.timestamp,
                                            modelId: (_c2 = chunk.modelId) != null ? _c2 : stepResponse.modelId
                                        };
                                        break;
                                    }
                                case "finish":
                                    {
                                        stepUsage = chunk.usage;
                                        stepFinishReason = chunk.finishReason;
                                        stepProviderMetadata = chunk.providerMetadata;
                                        const msToFinish = now2() - startTimestampMs;
                                        doStreamSpan.addEvent("ai.stream.finish");
                                        doStreamSpan.setAttributes({
                                            "ai.response.msToFinish": msToFinish,
                                            "ai.response.avgOutputTokensPerSecond": 1e3 * ((_d2 = stepUsage.outputTokens) != null ? _d2 : 0) / msToFinish
                                        });
                                        break;
                                    }
                                case "file":
                                    {
                                        stepContent.push(chunk);
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "source":
                                    {
                                        stepContent.push(chunk);
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "tool-call-streaming-start":
                                    {
                                        const tool2 = tools == null ? void 0 : tools[chunk.toolName];
                                        if ((tool2 == null ? void 0 : tool2.onArgsStreamingStart) != null) {
                                            await tool2.onArgsStreamingStart({
                                                toolCallId: chunk.toolCallId,
                                                messages: stepInputMessages,
                                                abortSignal
                                            });
                                        }
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "tool-call-delta":
                                    {
                                        const tool2 = tools == null ? void 0 : tools[chunk.toolName];
                                        if ((tool2 == null ? void 0 : tool2.onArgsStreamingDelta) != null) {
                                            await tool2.onArgsStreamingDelta({
                                                argsTextDelta: chunk.argsTextDelta,
                                                toolCallId: chunk.toolCallId,
                                                messages: stepInputMessages,
                                                abortSignal
                                            });
                                        }
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                case "error":
                                    {
                                        controller.enqueue(chunk);
                                        stepFinishReason = "error";
                                        break;
                                    }
                                case "raw":
                                    {
                                        controller.enqueue(chunk);
                                        break;
                                    }
                                default:
                                    {
                                        const exhaustiveCheck = chunkType;
                                        throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
                                    }
                            }
                        },
                        // invoke onFinish callback and resolve toolResults promise when the stream is about to close:
                        async flush (controller) {
                            const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;
                            try {
                                doStreamSpan.setAttributes(selectTelemetryAttributes({
                                    telemetry,
                                    attributes: {
                                        "ai.response.finishReason": stepFinishReason,
                                        "ai.response.text": {
                                            output: ()=>stepText
                                        },
                                        "ai.response.toolCalls": {
                                            output: ()=>stepToolCallsJson
                                        },
                                        "ai.response.id": stepResponse.id,
                                        "ai.response.model": stepResponse.modelId,
                                        "ai.response.timestamp": stepResponse.timestamp.toISOString(),
                                        "ai.usage.inputTokens": stepUsage.inputTokens,
                                        "ai.usage.outputTokens": stepUsage.outputTokens,
                                        "ai.usage.totalTokens": stepUsage.totalTokens,
                                        "ai.usage.reasoningTokens": stepUsage.reasoningTokens,
                                        "ai.usage.cachedInputTokens": stepUsage.cachedInputTokens,
                                        // standardized gen-ai llm span attributes:
                                        "gen_ai.response.finish_reasons": [
                                            stepFinishReason
                                        ],
                                        "gen_ai.response.id": stepResponse.id,
                                        "gen_ai.response.model": stepResponse.modelId,
                                        "gen_ai.usage.input_tokens": stepUsage.inputTokens,
                                        "gen_ai.usage.output_tokens": stepUsage.outputTokens
                                    }
                                }));
                            } catch (error) {} finally{
                                doStreamSpan.end();
                            }
                            controller.enqueue({
                                type: "finish-step",
                                finishReason: stepFinishReason,
                                usage: stepUsage,
                                providerMetadata: stepProviderMetadata,
                                response: {
                                    ...stepResponse,
                                    headers: response == null ? void 0 : response.headers
                                }
                            });
                            const combinedUsage = addLanguageModelUsage(usage, stepUsage);
                            await stepFinish.promise;
                            if (stepToolCalls.length > 0 && // all current tool calls have results:
                            stepToolResults.length === stepToolCalls.length && // continue until a stop condition is met:
                            !await isStopConditionMet({
                                stopConditions,
                                steps: recordedSteps
                            })) {
                                responseMessages.push(...toResponseMessages({
                                    content: stepContent,
                                    tools: tools != null ? tools : {}
                                }));
                                await streamStep({
                                    currentStep: currentStep + 1,
                                    responseMessages,
                                    usage: combinedUsage
                                });
                            } else {
                                controller.enqueue({
                                    type: "finish",
                                    finishReason: stepFinishReason,
                                    totalUsage: combinedUsage
                                });
                                self.closeStream();
                            }
                        }
                    })));
                }
                await streamStep({
                    currentStep: 0,
                    responseMessages: [],
                    usage: {
                        inputTokens: void 0,
                        outputTokens: void 0,
                        totalTokens: void 0
                    }
                });
            }
        }).catch((error)=>{
            self.addStream(new ReadableStream({
                start (controller) {
                    controller.enqueue({
                        type: "error",
                        error
                    });
                    controller.close();
                }
            }));
            self.closeStream();
        });
    }
    get steps() {
        return this._steps.promise;
    }
    get finalStep() {
        return this.steps.then((steps)=>steps[steps.length - 1]);
    }
    get content() {
        return this.finalStep.then((step)=>step.content);
    }
    get warnings() {
        return this.finalStep.then((step)=>step.warnings);
    }
    get providerMetadata() {
        return this.finalStep.then((step)=>step.providerMetadata);
    }
    get text() {
        return this.finalStep.then((step)=>step.text);
    }
    get reasoningText() {
        return this.finalStep.then((step)=>step.reasoningText);
    }
    get reasoning() {
        return this.finalStep.then((step)=>step.reasoning);
    }
    get sources() {
        return this.finalStep.then((step)=>step.sources);
    }
    get files() {
        return this.finalStep.then((step)=>step.files);
    }
    get toolCalls() {
        return this.finalStep.then((step)=>step.toolCalls);
    }
    get toolResults() {
        return this.finalStep.then((step)=>step.toolResults);
    }
    get usage() {
        return this.finalStep.then((step)=>step.usage);
    }
    get request() {
        return this.finalStep.then((step)=>step.request);
    }
    get response() {
        return this.finalStep.then((step)=>step.response);
    }
    get totalUsage() {
        return this._totalUsage.promise;
    }
    get finishReason() {
        return this._finishReason.promise;
    }
    /**
  Split out a new stream from the original stream.
  The original stream is replaced to allow for further splitting,
  since we do not know how many times the stream will be split.
  
  Note: this leads to buffering the stream content on the server.
  However, the LLM results are expected to be small enough to not cause issues.
     */ teeStream() {
        const [stream1, stream2] = this.baseStream.tee();
        this.baseStream = stream2;
        return stream1;
    }
    get textStream() {
        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({
            transform ({ part }, controller) {
                if (part.type === "text") {
                    controller.enqueue(part.text);
                }
            }
        })));
    }
    get fullStream() {
        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({
            transform ({ part }, controller) {
                controller.enqueue(part);
            }
        })));
    }
    async consumeStream(options) {
        var _a17;
        try {
            await consumeStream({
                stream: this.fullStream,
                onError: options == null ? void 0 : options.onError
            });
        } catch (error) {
            (_a17 = options == null ? void 0 : options.onError) == null ? void 0 : _a17.call(options, error);
        }
    }
    get experimental_partialOutputStream() {
        if (this.output == null) {
            throw new NoOutputSpecifiedError();
        }
        return createAsyncIterableStream(this.teeStream().pipeThrough(new TransformStream({
            transform ({ partialOutput }, controller) {
                if (partialOutput != null) {
                    controller.enqueue(partialOutput);
                }
            }
        })));
    }
    toUIMessageStream({ newMessageId, originalMessages = [], onFinish, messageMetadata, sendReasoning = false, sendSources = false, sendStart = true, sendFinish = true, onError = ()=>"An error occurred." } = {}) {
        const lastMessage = originalMessages[originalMessages.length - 1];
        const isContinuation = (lastMessage == null ? void 0 : lastMessage.role) === "assistant";
        const messageId = isContinuation ? lastMessage.id : newMessageId;
        const baseStream = this.fullStream.pipeThrough(new TransformStream({
            transform: async (part, controller)=>{
                const partType = part.type;
                switch(partType){
                    case "text":
                        {
                            controller.enqueue({
                                type: "text",
                                text: part.text
                            });
                            break;
                        }
                    case "reasoning":
                        {
                            if (sendReasoning) {
                                controller.enqueue({
                                    type: "reasoning",
                                    text: part.text,
                                    providerMetadata: part.providerMetadata
                                });
                            }
                            break;
                        }
                    case "reasoning-part-finish":
                        {
                            if (sendReasoning) {
                                controller.enqueue({
                                    type: "reasoning-part-finish"
                                });
                            }
                            break;
                        }
                    case "file":
                        {
                            controller.enqueue({
                                type: "file",
                                mediaType: part.file.mediaType,
                                url: `data:${part.file.mediaType};base64,${part.file.base64}`
                            });
                            break;
                        }
                    case "source":
                        {
                            if (sendSources && part.sourceType === "url") {
                                controller.enqueue({
                                    type: "source-url",
                                    sourceId: part.id,
                                    url: part.url,
                                    title: part.title,
                                    providerMetadata: part.providerMetadata
                                });
                            }
                            if (sendSources && part.sourceType === "document") {
                                controller.enqueue({
                                    type: "source-document",
                                    sourceId: part.id,
                                    mediaType: part.mediaType,
                                    title: part.title,
                                    filename: part.filename,
                                    providerMetadata: part.providerMetadata
                                });
                            }
                            break;
                        }
                    case "tool-call-streaming-start":
                        {
                            controller.enqueue({
                                type: "tool-call-streaming-start",
                                toolCallId: part.toolCallId,
                                toolName: part.toolName
                            });
                            break;
                        }
                    case "tool-call-delta":
                        {
                            controller.enqueue({
                                type: "tool-call-delta",
                                toolCallId: part.toolCallId,
                                argsTextDelta: part.argsTextDelta
                            });
                            break;
                        }
                    case "tool-call":
                        {
                            controller.enqueue({
                                type: "tool-call",
                                toolCallId: part.toolCallId,
                                toolName: part.toolName,
                                args: part.args
                            });
                            break;
                        }
                    case "tool-result":
                        {
                            controller.enqueue({
                                type: "tool-result",
                                toolCallId: part.toolCallId,
                                result: part.result
                            });
                            break;
                        }
                    case "error":
                        {
                            controller.enqueue({
                                type: "error",
                                errorText: onError(part.error)
                            });
                            break;
                        }
                    case "start-step":
                        {
                            const metadata = messageMetadata == null ? void 0 : messageMetadata({
                                part
                            });
                            controller.enqueue({
                                type: "start-step",
                                metadata
                            });
                            break;
                        }
                    case "finish-step":
                        {
                            const metadata = messageMetadata == null ? void 0 : messageMetadata({
                                part
                            });
                            controller.enqueue({
                                type: "finish-step",
                                metadata
                            });
                            break;
                        }
                    case "start":
                        {
                            if (sendStart) {
                                const metadata = messageMetadata == null ? void 0 : messageMetadata({
                                    part
                                });
                                controller.enqueue({
                                    type: "start",
                                    messageId,
                                    metadata
                                });
                            }
                            break;
                        }
                    case "finish":
                        {
                            if (sendFinish) {
                                const metadata = messageMetadata == null ? void 0 : messageMetadata({
                                    part
                                });
                                controller.enqueue({
                                    type: "finish",
                                    metadata
                                });
                            }
                            break;
                        }
                    case "raw":
                        {
                            break;
                        }
                    default:
                        {
                            const exhaustiveCheck = partType;
                            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);
                        }
                }
            }
        }));
        return handleUIMessageStreamFinish({
            stream: baseStream,
            newMessageId: messageId != null ? messageId : this.generateId(),
            originalMessages,
            onFinish
        });
    }
    pipeUIMessageStreamToResponse(response, { newMessageId, originalMessages, onFinish, messageMetadata, sendReasoning, sendSources, sendFinish, sendStart, onError, ...init } = {}) {
        pipeUIMessageStreamToResponse({
            response,
            stream: this.toUIMessageStream({
                newMessageId,
                originalMessages,
                onFinish,
                messageMetadata,
                sendReasoning,
                sendSources,
                sendFinish,
                sendStart,
                onError
            }),
            ...init
        });
    }
    pipeTextStreamToResponse(response, init) {
        pipeTextStreamToResponse({
            response,
            textStream: this.textStream,
            ...init
        });
    }
    toUIMessageStreamResponse({ newMessageId, originalMessages, onFinish, messageMetadata, sendReasoning, sendSources, sendFinish, sendStart, onError, ...init } = {}) {
        return createUIMessageStreamResponse({
            stream: this.toUIMessageStream({
                newMessageId,
                originalMessages,
                onFinish,
                messageMetadata,
                sendReasoning,
                sendSources,
                sendFinish,
                sendStart,
                onError
            }),
            ...init
        });
    }
    toTextStreamResponse(init) {
        return createTextStreamResponse({
            textStream: this.textStream,
            ...init
        });
    }
};
// core/middleware/default-settings-middleware.ts
function defaultSettingsMiddleware({ settings }) {
    return {
        middlewareVersion: "v2",
        transformParams: async ({ params })=>{
            return mergeObjects(settings, params);
        }
    };
}
// src/util/get-potential-start-index.ts
function getPotentialStartIndex(text2, searchedText) {
    if (searchedText.length === 0) {
        return null;
    }
    const directIndex = text2.indexOf(searchedText);
    if (directIndex !== -1) {
        return directIndex;
    }
    for(let i = text2.length - 1; i >= 0; i--){
        const suffix = text2.substring(i);
        if (searchedText.startsWith(suffix)) {
            return i;
        }
    }
    return null;
}
// core/middleware/extract-reasoning-middleware.ts
function extractReasoningMiddleware({ tagName, separator = "\n", startWithReasoning = false }) {
    const openingTag = `<${tagName}>`;
    const closingTag = `</${tagName}>`;
    return {
        middlewareVersion: "v2",
        wrapGenerate: async ({ doGenerate })=>{
            const { content, ...rest } = await doGenerate();
            const transformedContent = [];
            for (const part of content){
                if (part.type !== "text") {
                    transformedContent.push(part);
                    continue;
                }
                const text2 = startWithReasoning ? openingTag + part.text : part.text;
                const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, "gs");
                const matches = Array.from(text2.matchAll(regexp));
                if (!matches.length) {
                    transformedContent.push(part);
                    continue;
                }
                const reasoningText = matches.map((match)=>match[1]).join(separator);
                let textWithoutReasoning = text2;
                for(let i = matches.length - 1; i >= 0; i--){
                    const match = matches[i];
                    const beforeMatch = textWithoutReasoning.slice(0, match.index);
                    const afterMatch = textWithoutReasoning.slice(match.index + match[0].length);
                    textWithoutReasoning = beforeMatch + (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : "") + afterMatch;
                }
                transformedContent.push({
                    type: "reasoning",
                    text: reasoningText
                });
                transformedContent.push({
                    type: "text",
                    text: textWithoutReasoning
                });
            }
            return {
                content: transformedContent,
                ...rest
            };
        },
        wrapStream: async ({ doStream })=>{
            const { stream, ...rest } = await doStream();
            let isFirstReasoning = true;
            let isFirstText = true;
            let afterSwitch = false;
            let isReasoning = startWithReasoning;
            let buffer = "";
            return {
                stream: stream.pipeThrough(new TransformStream({
                    transform: (chunk, controller)=>{
                        if (chunk.type !== "text") {
                            controller.enqueue(chunk);
                            return;
                        }
                        buffer += chunk.text;
                        function publish(text2) {
                            if (text2.length > 0) {
                                const prefix = afterSwitch && (isReasoning ? !isFirstReasoning : !isFirstText) ? separator : "";
                                controller.enqueue(isReasoning ? {
                                    type: "reasoning",
                                    text: prefix + text2
                                } : {
                                    type: "text",
                                    text: prefix + text2
                                });
                                afterSwitch = false;
                                if (isReasoning) {
                                    isFirstReasoning = false;
                                } else {
                                    isFirstText = false;
                                }
                            }
                        }
                        do {
                            const nextTag = isReasoning ? closingTag : openingTag;
                            const startIndex = getPotentialStartIndex(buffer, nextTag);
                            if (startIndex == null) {
                                publish(buffer);
                                buffer = "";
                                break;
                            }
                            publish(buffer.slice(0, startIndex));
                            const foundFullMatch = startIndex + nextTag.length <= buffer.length;
                            if (foundFullMatch) {
                                buffer = buffer.slice(startIndex + nextTag.length);
                                if (isReasoning) {
                                    controller.enqueue({
                                        type: "reasoning-part-finish"
                                    });
                                }
                                isReasoning = !isReasoning;
                                afterSwitch = true;
                            } else {
                                buffer = buffer.slice(startIndex);
                                break;
                            }
                        }while (true)
                    }
                })),
                ...rest
            };
        }
    };
}
// core/middleware/simulate-streaming-middleware.ts
function simulateStreamingMiddleware() {
    return {
        middlewareVersion: "v2",
        wrapStream: async ({ doGenerate })=>{
            const result = await doGenerate();
            const simulatedStream = new ReadableStream({
                start (controller) {
                    controller.enqueue({
                        type: "stream-start",
                        warnings: result.warnings
                    });
                    controller.enqueue({
                        type: "response-metadata",
                        ...result.response
                    });
                    for (const part of result.content){
                        controller.enqueue(part);
                    }
                    controller.enqueue({
                        type: "finish",
                        finishReason: result.finishReason,
                        usage: result.usage,
                        providerMetadata: result.providerMetadata
                    });
                    controller.close();
                }
            });
            return {
                stream: simulatedStream,
                request: result.request,
                response: result.response
            };
        }
    };
}
// core/middleware/wrap-language-model.ts
var wrapLanguageModel = ({ model, middleware: middlewareArg, modelId, providerId })=>{
    return asArray(middlewareArg).reverse().reduce((wrappedModel, middleware)=>{
        return doWrap({
            model: wrappedModel,
            middleware,
            modelId,
            providerId
        });
    }, model);
};
var doWrap = ({ model, middleware: { transformParams, wrapGenerate, wrapStream }, modelId, providerId })=>{
    async function doTransform({ params, type }) {
        return transformParams ? await transformParams({
            params,
            type
        }) : params;
    }
    return {
        specificationVersion: "v2",
        provider: providerId != null ? providerId : model.provider,
        modelId: modelId != null ? modelId : model.modelId,
        // TODO middleware should be able to modify the supported urls
        get supportedUrls () {
            return model.supportedUrls;
        },
        async doGenerate (params) {
            const transformedParams = await doTransform({
                params,
                type: "generate"
            });
            const doGenerate = async ()=>model.doGenerate(transformedParams);
            const doStream = async ()=>model.doStream(transformedParams);
            return wrapGenerate ? wrapGenerate({
                doGenerate,
                doStream,
                params: transformedParams,
                model
            }) : doGenerate();
        },
        async doStream (params) {
            const transformedParams = await doTransform({
                params,
                type: "stream"
            });
            const doGenerate = async ()=>model.doGenerate(transformedParams);
            const doStream = async ()=>model.doStream(transformedParams);
            return wrapStream ? wrapStream({
                doGenerate,
                doStream,
                params: transformedParams,
                model
            }) : doStream();
        }
    };
};
;
function customProvider({ languageModels, textEmbeddingModels, imageModels, fallbackProvider }) {
    return {
        languageModel (modelId) {
            if (languageModels != null && modelId in languageModels) {
                return languageModels[modelId];
            }
            if (fallbackProvider) {
                return fallbackProvider.languageModel(modelId);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NoSuchModelError"]({
                modelId,
                modelType: "languageModel"
            });
        },
        textEmbeddingModel (modelId) {
            if (textEmbeddingModels != null && modelId in textEmbeddingModels) {
                return textEmbeddingModels[modelId];
            }
            if (fallbackProvider) {
                return fallbackProvider.textEmbeddingModel(modelId);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NoSuchModelError"]({
                modelId,
                modelType: "textEmbeddingModel"
            });
        },
        imageModel (modelId) {
            if (imageModels != null && modelId in imageModels) {
                return imageModels[modelId];
            }
            if (fallbackProvider == null ? void 0 : fallbackProvider.imageModel) {
                return fallbackProvider.imageModel(modelId);
            }
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NoSuchModelError"]({
                modelId,
                modelType: "imageModel"
            });
        }
    };
}
var experimental_customProvider = customProvider;
;
var name16 = "AI_NoSuchProviderError";
var marker16 = `vercel.ai.error.${name16}`;
var symbol16 = Symbol.for(marker16);
var _a16;
var NoSuchProviderError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NoSuchModelError"] {
    constructor({ modelId, modelType, providerId, availableProviders, message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})` }){
        super({
            errorName: name16,
            modelId,
            modelType,
            message
        });
        this[_a16] = true;
        this.providerId = providerId;
        this.availableProviders = availableProviders;
    }
    static isInstance(error) {
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"].hasMarker(error, marker16);
    }
};
_a16 = symbol16;
;
function createProviderRegistry(providers, { separator = ":" } = {}) {
    const registry = new DefaultProviderRegistry({
        separator
    });
    for (const [id, provider] of Object.entries(providers)){
        registry.registerProvider({
            id,
            provider
        });
    }
    return registry;
}
var experimental_createProviderRegistry = createProviderRegistry;
var DefaultProviderRegistry = class {
    constructor({ separator }){
        this.providers = {};
        this.separator = separator;
    }
    registerProvider({ id, provider }) {
        this.providers[id] = provider;
    }
    getProvider(id) {
        const provider = this.providers[id];
        if (provider == null) {
            throw new NoSuchProviderError({
                modelId: id,
                modelType: "languageModel",
                providerId: id,
                availableProviders: Object.keys(this.providers)
            });
        }
        return provider;
    }
    splitId(id, modelType) {
        const index = id.indexOf(this.separator);
        if (index === -1) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NoSuchModelError"]({
                modelId: id,
                modelType,
                message: `Invalid ${modelType} id for registry: ${id} (must be in the format "providerId${this.separator}modelId")`
            });
        }
        return [
            id.slice(0, index),
            id.slice(index + this.separator.length)
        ];
    }
    languageModel(id) {
        var _a17, _b;
        const [providerId, modelId] = this.splitId(id, "languageModel");
        const model = (_b = (_a17 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a17, modelId);
        if (model == null) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NoSuchModelError"]({
                modelId: id,
                modelType: "languageModel"
            });
        }
        return model;
    }
    textEmbeddingModel(id) {
        var _a17;
        const [providerId, modelId] = this.splitId(id, "textEmbeddingModel");
        const provider = this.getProvider(providerId);
        const model = (_a17 = provider.textEmbeddingModel) == null ? void 0 : _a17.call(provider, modelId);
        if (model == null) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NoSuchModelError"]({
                modelId: id,
                modelType: "textEmbeddingModel"
            });
        }
        return model;
    }
    imageModel(id) {
        var _a17;
        const [providerId, modelId] = this.splitId(id, "imageModel");
        const provider = this.getProvider(providerId);
        const model = (_a17 = provider.imageModel) == null ? void 0 : _a17.call(provider, modelId);
        if (model == null) {
            throw new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NoSuchModelError"]({
                modelId: id,
                modelType: "imageModel"
            });
        }
        return model;
    }
};
;
// core/tool/tool.ts
function tool(tool2) {
    return tool2;
}
;
;
;
var LATEST_PROTOCOL_VERSION = "2024-11-05";
var SUPPORTED_PROTOCOL_VERSIONS = [
    LATEST_PROTOCOL_VERSION,
    "2024-10-07"
];
var ClientOrServerImplementationSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    version: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
}).passthrough();
var BaseParamsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    _meta: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({}).passthrough())
}).passthrough();
var ResultSchema = BaseParamsSchema;
var RequestSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    params: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(BaseParamsSchema)
});
var ServerCapabilitiesSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    experimental: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({}).passthrough()),
    logging: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({}).passthrough()),
    prompts: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        listChanged: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean())
    }).passthrough()),
    resources: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        subscribe: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean()),
        listChanged: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean())
    }).passthrough()),
    tools: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        listChanged: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean())
    }).passthrough())
}).passthrough();
var InitializeResultSchema = ResultSchema.extend({
    protocolVersion: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    capabilities: ServerCapabilitiesSchema,
    serverInfo: ClientOrServerImplementationSchema,
    instructions: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
});
var PaginatedResultSchema = ResultSchema.extend({
    nextCursor: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
});
var ToolSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    name: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    description: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()),
    inputSchema: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("object"),
        properties: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({}).passthrough())
    }).passthrough()
}).passthrough();
var ListToolsResultSchema = PaginatedResultSchema.extend({
    tools: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(ToolSchema)
});
var TextContentSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("text"),
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
}).passthrough();
var ImageContentSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("image"),
    data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().base64(),
    mimeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
}).passthrough();
var ResourceContentsSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    /**
   * The URI of this resource.
   */ uri: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    /**
   * The MIME type of this resource, if known.
   */ mimeType: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string())
}).passthrough();
var TextResourceContentsSchema = ResourceContentsSchema.extend({
    text: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string()
});
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
    blob: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string().base64()
});
var EmbeddedResourceSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    type: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal("resource"),
    resource: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        TextResourceContentsSchema,
        BlobResourceContentsSchema
    ])
}).passthrough();
var CallToolResultSchema = ResultSchema.extend({
    content: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].array(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        TextContentSchema,
        ImageContentSchema,
        EmbeddedResourceSchema
    ])),
    isError: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].boolean().default(false).optional()
}).or(ResultSchema.extend({
    toolResult: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown()
}));
// core/tool/mcp/json-rpc-message.ts
var JSONRPC_VERSION = "2.0";
var JSONRPCRequestSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    jsonrpc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(JSONRPC_VERSION),
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().int()
    ])
}).merge(RequestSchema).strict();
var JSONRPCResponseSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    jsonrpc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(JSONRPC_VERSION),
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().int()
    ]),
    result: ResultSchema
}).strict();
var JSONRPCErrorSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    jsonrpc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(JSONRPC_VERSION),
    id: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().int()
    ]),
    error: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
        code: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].number().int(),
        message: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
        data: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].unknown())
    })
}).strict();
var JSONRPCNotificationSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    jsonrpc: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].literal(JSONRPC_VERSION)
}).merge(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].object({
    method: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].string(),
    params: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].optional(BaseParamsSchema)
})).strict();
var JSONRPCMessageSchema = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$zod$2f$dist$2f$esm$2f$v3$2f$external$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__$2a$__as__z$3e$__["z"].union([
    JSONRPCRequestSchema,
    JSONRPCNotificationSchema,
    JSONRPCResponseSchema,
    JSONRPCErrorSchema
]);
// core/tool/mcp/mcp-sse-transport.ts
var SseMCPTransport = class {
    constructor({ url, headers }){
        this.connected = false;
        this.url = new URL(url);
        this.headers = headers;
    }
    async start() {
        return new Promise((resolve, reject)=>{
            if (this.connected) {
                return resolve();
            }
            this.abortController = new AbortController();
            const establishConnection = async ()=>{
                var _a17, _b, _c;
                try {
                    const headers = new Headers(this.headers);
                    headers.set("Accept", "text/event-stream");
                    const response = await fetch(this.url.href, {
                        headers,
                        signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal
                    });
                    if (!response.ok || !response.body) {
                        const error = new MCPClientError({
                            message: `MCP SSE Transport Error: ${response.status} ${response.statusText}`
                        });
                        (_b = this.onerror) == null ? void 0 : _b.call(this, error);
                        return reject(error);
                    }
                    const stream = response.body.pipeThrough(new TextDecoderStream()).pipeThrough((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["createEventSourceParserStream"])());
                    const reader = stream.getReader();
                    const processEvents = async ()=>{
                        var _a18, _b2, _c2;
                        try {
                            while(true){
                                const { done, value } = await reader.read();
                                if (done) {
                                    if (this.connected) {
                                        this.connected = false;
                                        throw new MCPClientError({
                                            message: "MCP SSE Transport Error: Connection closed unexpectedly"
                                        });
                                    }
                                    return;
                                }
                                const { event, data } = value;
                                if (event === "endpoint") {
                                    this.endpoint = new URL(data, this.url);
                                    if (this.endpoint.origin !== this.url.origin) {
                                        throw new MCPClientError({
                                            message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`
                                        });
                                    }
                                    this.connected = true;
                                    resolve();
                                } else if (event === "message") {
                                    try {
                                        const message = JSONRPCMessageSchema.parse(JSON.parse(data));
                                        (_a18 = this.onmessage) == null ? void 0 : _a18.call(this, message);
                                    } catch (error) {
                                        const e = new MCPClientError({
                                            message: "MCP SSE Transport Error: Failed to parse message",
                                            cause: error
                                        });
                                        (_b2 = this.onerror) == null ? void 0 : _b2.call(this, e);
                                    }
                                }
                            }
                        } catch (error) {
                            if (error instanceof Error && error.name === "AbortError") {
                                return;
                            }
                            (_c2 = this.onerror) == null ? void 0 : _c2.call(this, error);
                            reject(error);
                        }
                    };
                    this.sseConnection = {
                        close: ()=>reader.cancel()
                    };
                    processEvents();
                } catch (error) {
                    if (error instanceof Error && error.name === "AbortError") {
                        return;
                    }
                    (_c = this.onerror) == null ? void 0 : _c.call(this, error);
                    reject(error);
                }
            };
            establishConnection();
        });
    }
    async close() {
        var _a17, _b, _c;
        this.connected = false;
        (_a17 = this.sseConnection) == null ? void 0 : _a17.close();
        (_b = this.abortController) == null ? void 0 : _b.abort();
        (_c = this.onclose) == null ? void 0 : _c.call(this);
    }
    async send(message) {
        var _a17, _b, _c;
        if (!this.endpoint || !this.connected) {
            throw new MCPClientError({
                message: "MCP SSE Transport Error: Not connected"
            });
        }
        try {
            const headers = new Headers(this.headers);
            headers.set("Content-Type", "application/json");
            const init = {
                method: "POST",
                headers,
                body: JSON.stringify(message),
                signal: (_a17 = this.abortController) == null ? void 0 : _a17.signal
            };
            const response = await fetch(this.endpoint, init);
            if (!response.ok) {
                const text2 = await response.text().catch(()=>null);
                const error = new MCPClientError({
                    message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text2}`
                });
                (_b = this.onerror) == null ? void 0 : _b.call(this, error);
                return;
            }
        } catch (error) {
            (_c = this.onerror) == null ? void 0 : _c.call(this, error);
            return;
        }
    }
};
// core/tool/mcp/mcp-transport.ts
function createMcpTransport(config) {
    if (config.type !== "sse") {
        throw new MCPClientError({
            message: "Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface."
        });
    }
    return new SseMCPTransport(config);
}
function isCustomMcpTransport(transport) {
    return "start" in transport && typeof transport.start === "function" && "send" in transport && typeof transport.send === "function" && "close" in transport && typeof transport.close === "function";
}
// core/tool/mcp/mcp-client.ts
var CLIENT_VERSION = "1.0.0";
async function createMCPClient(config) {
    const client = new MCPClient(config);
    await client.init();
    return client;
}
var MCPClient = class {
    constructor({ transport: transportConfig, name: name17 = "ai-sdk-mcp-client", onUncaughtError }){
        this.requestMessageId = 0;
        this.responseHandlers = /* @__PURE__ */ new Map();
        this.serverCapabilities = {};
        this.isClosed = true;
        this.onUncaughtError = onUncaughtError;
        if (isCustomMcpTransport(transportConfig)) {
            this.transport = transportConfig;
        } else {
            this.transport = createMcpTransport(transportConfig);
        }
        this.transport.onclose = ()=>this.onClose();
        this.transport.onerror = (error)=>this.onError(error);
        this.transport.onmessage = (message)=>{
            if ("method" in message) {
                this.onError(new MCPClientError({
                    message: "Unsupported message type"
                }));
                return;
            }
            this.onResponse(message);
        };
        this.clientInfo = {
            name: name17,
            version: CLIENT_VERSION
        };
    }
    async init() {
        try {
            await this.transport.start();
            this.isClosed = false;
            const result = await this.request({
                request: {
                    method: "initialize",
                    params: {
                        protocolVersion: LATEST_PROTOCOL_VERSION,
                        capabilities: {},
                        clientInfo: this.clientInfo
                    }
                },
                resultSchema: InitializeResultSchema
            });
            if (result === void 0) {
                throw new MCPClientError({
                    message: "Server sent invalid initialize result"
                });
            }
            if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
                throw new MCPClientError({
                    message: `Server's protocol version is not supported: ${result.protocolVersion}`
                });
            }
            this.serverCapabilities = result.capabilities;
            await this.notification({
                method: "notifications/initialized"
            });
            return this;
        } catch (error) {
            await this.close();
            throw error;
        }
    }
    async close() {
        var _a17;
        if (this.isClosed) return;
        await ((_a17 = this.transport) == null ? void 0 : _a17.close());
        this.onClose();
    }
    assertCapability(method) {
        switch(method){
            case "initialize":
                break;
            case "tools/list":
            case "tools/call":
                if (!this.serverCapabilities.tools) {
                    throw new MCPClientError({
                        message: `Server does not support tools`
                    });
                }
                break;
            default:
                throw new MCPClientError({
                    message: `Unsupported method: ${method}`
                });
        }
    }
    async request({ request, resultSchema, options }) {
        return new Promise((resolve, reject)=>{
            if (this.isClosed) {
                return reject(new MCPClientError({
                    message: "Attempted to send a request from a closed client"
                }));
            }
            this.assertCapability(request.method);
            const signal = options == null ? void 0 : options.signal;
            signal == null ? void 0 : signal.throwIfAborted();
            const messageId = this.requestMessageId++;
            const jsonrpcRequest = {
                ...request,
                jsonrpc: "2.0",
                id: messageId
            };
            const cleanup = ()=>{
                this.responseHandlers.delete(messageId);
            };
            this.responseHandlers.set(messageId, (response)=>{
                if (signal == null ? void 0 : signal.aborted) {
                    return reject(new MCPClientError({
                        message: "Request was aborted",
                        cause: signal.reason
                    }));
                }
                if (response instanceof Error) {
                    return reject(response);
                }
                try {
                    const result = resultSchema.parse(response.result);
                    resolve(result);
                } catch (error) {
                    const parseError = new MCPClientError({
                        message: "Failed to parse server response",
                        cause: error
                    });
                    reject(parseError);
                }
            });
            this.transport.send(jsonrpcRequest).catch((error)=>{
                cleanup();
                reject(error);
            });
        });
    }
    async listTools({ params, options } = {}) {
        try {
            return this.request({
                request: {
                    method: "tools/list",
                    params
                },
                resultSchema: ListToolsResultSchema,
                options
            });
        } catch (error) {
            throw error;
        }
    }
    async callTool({ name: name17, args, options }) {
        try {
            return this.request({
                request: {
                    method: "tools/call",
                    params: {
                        name: name17,
                        arguments: args
                    }
                },
                resultSchema: CallToolResultSchema,
                options: {
                    signal: options == null ? void 0 : options.abortSignal
                }
            });
        } catch (error) {
            throw error;
        }
    }
    async notification(notification) {
        const jsonrpcNotification = {
            ...notification,
            jsonrpc: "2.0"
        };
        await this.transport.send(jsonrpcNotification);
    }
    /**
   * Returns a set of AI SDK tools from the MCP server
   * @returns A record of tool names to their implementations
   */ async tools({ schemas = "automatic" } = {}) {
        var _a17;
        const tools = {};
        try {
            const listToolsResult = await this.listTools();
            for (const { name: name17, description, inputSchema } of listToolsResult.tools){
                if (schemas !== "automatic" && !(name17 in schemas)) {
                    continue;
                }
                const parameters = schemas === "automatic" ? (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2d$utils$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["jsonSchema"])({
                    ...inputSchema,
                    properties: (_a17 = inputSchema.properties) != null ? _a17 : {},
                    additionalProperties: false
                }) : schemas[name17].parameters;
                const self = this;
                const toolWithExecute = tool({
                    description,
                    parameters,
                    execute: async (args, options)=>{
                        var _a18;
                        (_a18 = options == null ? void 0 : options.abortSignal) == null ? void 0 : _a18.throwIfAborted();
                        return self.callTool({
                            name: name17,
                            args,
                            options
                        });
                    }
                });
                tools[name17] = toolWithExecute;
            }
            return tools;
        } catch (error) {
            throw error;
        }
    }
    onClose() {
        if (this.isClosed) return;
        this.isClosed = true;
        const error = new MCPClientError({
            message: "Connection closed"
        });
        for (const handler of this.responseHandlers.values()){
            handler(error);
        }
        this.responseHandlers.clear();
    }
    onError(error) {
        if (this.onUncaughtError) {
            this.onUncaughtError(error);
        }
    }
    onResponse(response) {
        const messageId = Number(response.id);
        const handler = this.responseHandlers.get(messageId);
        if (handler === void 0) {
            throw new MCPClientError({
                message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(response)}`
            });
        }
        this.responseHandlers.delete(messageId);
        handler("result" in response ? response : new MCPClientError({
            message: response.error.message,
            cause: response.error
        }));
    }
};
;
var NoTranscriptGeneratedError = class extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$ai$2d$sdk$2f$provider$2f$dist$2f$index$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AISDKError"] {
    constructor(options){
        super({
            name: "AI_NoTranscriptGeneratedError",
            message: "No transcript generated."
        });
        this.responses = options.responses;
    }
};
// core/transcribe/transcribe.ts
async function transcribe({ model, audio, providerOptions = {}, maxRetries: maxRetriesArg, abortSignal, headers }) {
    const { retry } = prepareRetries({
        maxRetries: maxRetriesArg
    });
    const audioData = audio instanceof URL ? (await download({
        url: audio
    })).data : convertDataContentToUint8Array(audio);
    const result = await retry(()=>{
        var _a17;
        return model.doGenerate({
            audio: audioData,
            abortSignal,
            headers,
            providerOptions,
            mediaType: (_a17 = detectMediaType({
                data: audioData,
                signatures: audioMediaTypeSignatures
            })) != null ? _a17 : "audio/wav"
        });
    });
    if (!result.text) {
        throw new NoTranscriptGeneratedError({
            responses: [
                result.response
            ]
        });
    }
    return new DefaultTranscriptionResult({
        text: result.text,
        segments: result.segments,
        language: result.language,
        durationInSeconds: result.durationInSeconds,
        warnings: result.warnings,
        responses: [
            result.response
        ],
        providerMetadata: result.providerMetadata
    });
}
var DefaultTranscriptionResult = class {
    constructor(options){
        var _a17;
        this.text = options.text;
        this.segments = options.segments;
        this.language = options.language;
        this.durationInSeconds = options.durationInSeconds;
        this.warnings = options.warnings;
        this.responses = options.responses;
        this.providerMetadata = (_a17 = options.providerMetadata) != null ? _a17 : {};
    }
};
;
 //# sourceMappingURL=index.mjs.map
}}),

};

//# sourceMappingURL=node_modules_ai_dist_index_mjs_3acd22fd._.js.map